#+TITLE: Emacs Configuration
#+PROPERTY: header-args :results silent
* Starting Up
** Daemon Mode
#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC
** Time Startup
On start-up, display how quickly Emacs started up.
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+END_SRC
** Add Package Sources
#+BEGIN_SRC emacs-lisp
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t))
#+END_SRC
Use ~use-package~.
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC
Always.
#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
#+END_SRC
Use ~M-x package-refresh-contents~ to reload the list of packages after adding the package sources for the first time.
** Add Elisp Directory and Custom Directory
If I ever need to load files outside of my package system, I know where to find
them. I also set up ~use-package~ here.
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/elisp/")
(setq use-package-verbose t)
(setq use-package-always-ensure t)
(require 'use-package)
#+END_SRC
I put custom variables outside of my init.el file.
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+END_SRC
** Common Lisp
#+BEGIN_SRC emacs-lisp
(require 'cl)
#+END_SRC
* General Configuration
** Graphics
*** Decluttering
**** Splash Screen
Get rid of that ugly splash screen.
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
#+END_SRC
**** Fullscreen
Start emacs in glorious fullscreen.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
(setq frame-title-format "")
#+END_SRC
**** Bars
Menus are not required; neither is the scroll bar.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC
It is no longer the 90s. Toolbars and their little icons are not cool.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
#+END_SRC
**** Cursor Blinking
I find cursor blinking distracting.
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
(when (display-graphic-p)
  (setq-default cursor-type 'box))
(setq x-stretch-cursor 1)
#+END_SRC
**** Bells
Visual, not audible bells.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(setq visible-bell t)
#+END_SRC
**** Auto-revert
Turn off reverting buffer messages.
#+BEGIN_SRC emacs-lisp
(setq auto-revert-verbose nil)
#+END_SRC
**** Autosave
Turn off autosave messages. To do this, we define our own auto-save function and
replace the built-in one with ours.
#+BEGIN_SRC emacs-lisp
(setq auto-save-timeout 99999)
(defvar bjm/auto-save-timer nil
  "Timer to run `bjm/auto-save-silent'")
(defvar bjm/auto-save-interval 15
  "How often in seconds of idle time to auto-save with `bjm/auto-save-silent'")
(defun bjm/auto-save-silent ()
  "Auto-save all buffers silently"
  (interactive)
  (do-auto-save t))
(setq bjm/auto-save-timer
      (run-with-idle-timer 0 bjm/auto-save-interval #'bjm/auto-save-silent))
#+END_SRC
**** Modeline
Keep a simpler modeline...
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :defer 1)
#+END_SRC
and a smarter one.
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :defer 2
  :config
  (sml/setup))
#+END_SRC
*** Modeline
**** Time
What time is it, Mr. Emacs?
#+BEGIN_SRC emacs-lisp
(display-time-mode 1)
(setq display-time-format "%l:%M%p")
#+END_SRC
**** Column
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
#+END_SRC
*** Ban Whitespace
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook #'delete-trailing-whitespace)
#+END_SRC
*** Indentation
**** Keep Things Indented
#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :disabled
  :diminish aggressive-indent-mode
  :hook
  (prog-mode . aggressive-indent-mode)
  (python-mode . (lambda () (aggressive-indent-mode -1))))
#+END_SRC
**** Wrap Indented Lines Sensibly
This way, indented lines that are wrapped with ~visual-line-mode~ do not begin at character 0, but from where they are indented.
#+BEGIN_SRC emacs-lisp
(use-package adaptive-wrap)
(when (fboundp 'adaptive-wrap-prefix-mode)
  (defun my-activate-adaptive-wrap-prefix-mode ()
    "Toggle `visual-line-mode' and `adaptive-wrap-prefix-mode' simultaneously."
    (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1)))
  (add-hook 'visual-line-mode-hook 'my-activate-adaptive-wrap-prefix-mode))
#+END_SRC
*** Mouse Scrolling
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed t) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse t) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
#+END_SRC
*** Indentation
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq indent-line-function #'insert-tab)
#+END_SRC
** Ease of Use
*** Better Defaults
All the things (perhaps they seem little) that just make sense to have.
**** From Yes/No to y/n
This makes things so much simpler. There's not any ambiguity to begin with.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
**** Sentences End With a Single Space
This is necessary to make sentence navigation commands work for me.
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
**** Delete The Selection
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC
**** Split Vertically by Default
Gotta maximize that vertical screen space. Besides, I always have 80 character
limits on my lines.
#+BEGIN_SRC emacs-lisp
(setq split-height-threshold nil)
(setq split-width-threshold 0)
#+END_SRC
**** Kill Current Buffer
Kill the current buffer.
#+BEGIN_SRC emacs-lisp
(defun bjm/kill-this-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))
#+END_SRC
**** Remember File Variables
#+BEGIN_SRC emacs-lisp
(defun risky-local-variable-p (sym &optional _ignored) nil)
#+END_SRC
**** Reload Files On Update
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC
**** Complete Reload
Completely reload emacs, by reloading the init file.
#+BEGIN_SRC emacs-lisp
(defun gm/reload ()
  (interactive)
  (load-file "~/.emacs.d/init.el"))
#+END_SRC
**** Dictionary
#+BEGIN_SRC emacs-lisp
(require 'sdcv-mode)
#+END_SRC
**** Transient Mark Mode
#+BEGIN_SRC emacs-lisp
(transient-mark-mode 1)
#+END_SRC
**** Electric Pairs Mode
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
(setq electric-pair-pairs
      '((?\( . ?\))
        (?\" . ?\")
        (?\{ . ?\})))
#+END_SRC
*** Backups
Keep backups in a dedicated spot and not in the current directory: this saves so much clutter
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC
Also, I have lots of disk space, and not so much patience when I lose an important file. So I save lots.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC
**** History
It's nice to have a history of commands so that when you open a new emacs instance, you can get right to work.
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
***** Desktop
On a similar note, save the desktop.
#+BEGIN_SRC emacs-lisp
(desktop-save-mode 1)
(setq desktop-restore-eager 250)
#+END_SRC
Make two buffers with the same file name distinguishable.
#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :defer 1
  :ensure nil
  :custom
  (uniquify-after-kill-buffer-p t)
  (uniquify-buffer-name-style 'post-forward)
  (uniquify-strip-common-suffix t))
#+END_SRC
***** Save Place
Opens a file to the same place in which it was last closed.
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC
*** Abbreviations
Load them.
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/abbrevs.el")
#+END_SRC
Always use this wonderful tool.
#+BEGIN_SRC emacs-lispn
(abbrev-mode 1)
#+END_SRC
Because it's always on, we don't need to know about it.
#+BEGIN_SRC emacs-lisp
(diminish 'abbrev-mode)
#+END_SRC
Save them in the ~.emacs.d~ dir.
#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name "~/.emacs.d/abbrevs.el")
#+END_SRC
Save abbreviations upon saving a file.
#+BEGIN_SRC emacs-lisp
(setq save-abbrevs 'silent)
#+END_SRC
*** Key Frequency
#+BEGIN_SRC emacs-lisp
(use-package keyfreq)
(keyfreq-mode 1)
(keyfreq-autosave-mode 1)
#+END_SRC
*** Searching
Use =ack= instead of =grep=.
#+BEGIN_SRC emacs-lisp
(defvar ack-history nil
  "History for the `ack' command.")

(defun ack (command-args)
  (interactive
   (let ((ack-command "ack --nofilter --nogroup --with-filename "))
     (list (read-shell-command "Run ack (like this): "
                               ack-command
                               'ack-history))))
  (let ((compilation-disable-input t))
    (compilation-start (concat command-args " < " null-device)
                       'grep-mode)))
#+END_SRC
*** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :diminish
  :config
  (ivy-mode 1)
  (diminish 'ivy-mode)
  :custom
  (ivy-use-virtual-buffers t)
  (ivy-display-style 'fancy)
  (ivy-re-builders-alist
   '((swiper . ivy--regex-plus)
     (t      . ivy--regex-fuzzy)))
  (ivy-initial-inputs-alist nil))
(use-package swiper)
(use-package counsel)
#+END_SRC
*** Programming
Check syntax.
#+BEGIN_SRC emacs-lisp
(use-package flycheck)
(global-flycheck-mode)
#+END_SRC
**** Python
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook #'linum-relative-mode)
#+END_SRC
Turn Emacs into basically a Python IDE.
#+BEGIN_SRC emacs-lisp
(elpy-enable)
(setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
(use-package py-autopep8)
(add-hook 'python-mode-hook #'elpy-mode)
(add-hook 'elpy-mode-hook #'py-autopep8-enable-on-save)
(add-hook 'elpy-mode-hook #'flycheck-mode)
#+END_SRC
*** Expand Region
#+BEGIN_SRC emacs-lisp
(use-package expand-region)
(bind-key "C-=" 'er/expand-region)
#+END_SRC
** Packages
*** Magit
#+BEGIN_SRC emacs-lisp
(use-package magit)
#+END_SRC
*** Dired
**** Revert Buffer
Have the most up-to-date version of the buffer when using dired.
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC
**** Declutter
#+BEGIN_SRC emacs-lisp
(defun xah-dired-mode-setup ()
  "to be run as hook for `dired-mode'."
  (dired-hide-details-mode 1))
(add-hook 'dired-mode-hook #'xah-dired-mode-setup)
#+END_SRC
**** Copy and Delete
Allow dired to recursively copy and delete directories. ~always~ ensures that no
confirmation dialog comes up, and ~top~ does it only once.
#+BEGIN_SRC emacs-lisp
(setq dired-recursive-copies (quote always))
(setq dired-recursive-deletes (quote top))
#+END_SRC
**** Speed Sorting
Easily sort based on a lot of options such as name, time, size, and
extension. Use ~S~ to use in a dired buffer.
#+BEGIN_SRC emacs-lisp
(use-package dired-quick-sort
  :ensure t
  :config
  (dired-quick-sort-setup))
#+END_SRC
*** God Mode
Enable god-mode.
#+BEGIN_SRC emacs-lisp
(use-package god-mode
  :ensure t)
#+END_SRC
**** Indicate Mode with Modeline
#+BEGIN_SRC emacs-lisp
(defun me//god-mode-indicator ()
  (cond (god-local-mode
         (progn
           (set-cursor-color "#dc322f")))
        (t
         (progn
           (set-cursor-color "#657b83")))))

(add-hook 'god-mode-enabled-hook #'me//god-mode-indicator)
(add-hook 'god-mode-disabled-hook #'me//god-mode-indicator)
#+END_SRC
*** PDF Tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :pin manual
  :config
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-page) ;
  (setq pdf-annot-activate-created-annotations t)
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
  (setq pdf-view-resize-factor 1.1)
  (define-key pdf-view-mode-map (kbd "h") 'pdf-annot-add-highlight-markup-annotation)
  (define-key pdf-view-mode-map (kbd "t") 'pdf-annot-add-text-annotation)
  (define-key pdf-view-mode-map (kbd "D") 'pdf-annot-delete)
  :hook (pdf-view-mode pdf-view-midnight-minor-mode))
#+END_SRC
*** Webmode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :init (add-to-list 'auto-mode-alist '("\\.scss\\'" . web-mode))
  :custom
  (web-mode-markup-indent-offset 2)
  (web-mode-css-indent-offset 2)
  (web-mode-code-indent-offset 2))
#+END_SRC
** Theme
*** Solarized Light
#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :config (load-theme 'solarized-light t))
#+END_SRC
*** Font Face
Normally use Hack.
#+BEGIN_SRC emacs-lisp
(set-face-font 'default "Hack")
(set-frame-font "Hack" nil t)
(set-face-font 'variable-pitch "Palatino Linotype")
#+END_SRC
*** Autofill
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode 1)
#+END_SRC
Nicely wrap lines for text mode.
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'auto-fill-mode)
(add-hook 'change-log-mode-hook 'turn-on-auto-fill)
(eval-after-load "diminish" '(diminish 'auto-fill-mode-mode))
#+END_SRC
**** 80 Columns
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook
          (lambda() (set-fill-column 80)))
#+END_SRC
*** Highlighting
**** Syntax
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode 1)
#+END_SRC
**** Rainbow Mode
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode)
(rainbow-mode 1)
(diminish 'rainbow-mode)
#+END_SRC
**** Source Code Blocks
Native syntax highlighting for source blocks in org mode.
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-confirm-babel-evaluate nil
      org-edit-src-content-indentation 0)
#+END_SRC
**** Parentheses
#+BEGIN_SRC emacs-lisp
(setq blink-matching-paren nil)
(show-paren-mode t)
(setq show-paren-delay 0)
(setq show-paren-style 'expression)
#+END_SRC
* Keybindings
** Conditional Keybindings
Obtained from [[http://endlessparentheses.com/define-context-aware-keys-in-emacs.html][Define context-aware keys in Emacs ¬∑ Endless Parentheses]].
#+BEGIN_SRC emacs-lisp
(defmacro define-conditional-key (keymap key def
                                                 &rest body)
  "In KEYMAP, define key sequence KEY as DEF conditionally.
This is like `define-key', except the definition
\"disappears\" whenever BODY evaluates to nil."
  (declare (indent 3)
           (debug (form form form &rest sexp)))
  `(define-key ,keymap ,key
     '(menu-item
       ,(format "maybe-%s" (or (car (cdr-safe def)) def))
       nil
       :filter (lambda (&optional _)
                 (when ,(macroexp-progn body)
                   ,def)))))
#+END_SRC
** Better Defaults
These are what I think are better bindings for or better versions of the default
commands.
*** Easy M-x
Alt is hard to type easily.
#+BEGIN_SRC emacs-lisp
(bind-key "C-SPC" 'execute-extended-command)
(bind-key "C-M-SPC" 'amx-major-mode-commands)
(bind-key "C-c C-SPC" 'execute-extended-command)
#+END_SRC
*** Set Mark
Need a replacement because we rebound ~C-SPC~ above.
#+BEGIN_SRC emacs-lisp
(bind-key "C-t" 'set-mark-command)
#+END_SRC
*** Shell Kill Word
#+BEGIN_SRC emacs-lisp
(bind-key "C-w" 'backward-kill-word)
#+END_SRC
*** Cut/Paste
#+BEGIN_SRC emacs-lisp
(defun xah-cut-line-or-region ()
  "Cut current line, or text selection.
When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region').

URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2015-06-10"
  (interactive)
  (if current-prefix-arg
      (progn ; not using kill-region because we don't want to include previous kill
        (kill-new (buffer-string))
        (delete-region (point-min) (point-max)))
    (progn (if (use-region-p)
               (kill-region (region-beginning) (region-end) t)
             (kill-region (line-beginning-position) (line-beginning-position 2))))))

(defun xah-copy-line-or-region ()
  "Copy current line, or text selection.
When called repeatedly, append copy subsequent lines.
When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').

URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2018-09-10"
  (interactive)
  (if current-prefix-arg
      (progn
        (copy-region-as-kill (point-min) (point-max)))
    (if (use-region-p)
        (progn
          (copy-region-as-kill (region-beginning) (region-end)))
      (if (eq last-command this-command)
          (if (eobp)
              (progn )
            (progn
              (kill-append "\n" nil)
              (kill-append
               (buffer-substring-no-properties (line-beginning-position) (line-end-position))
               nil)
              (progn
                (end-of-line)
                (forward-char))))
        (if (eobp)
            (if (eq (char-before) 10 )
                (progn )
              (progn
                (copy-region-as-kill (line-beginning-position) (line-end-position))
                (end-of-line)))
          (progn
            (copy-region-as-kill (line-beginning-position) (line-end-position))
            (end-of-line)
            (forward-char)))))))

(bind-key "C-k" 'xah-cut-line-or-region)
(bind-key "M-w" 'xah-copy-line-or-region)
#+END_SRC
*** Normal Undo Binding
#+BEGIN_SRC emacs-lisp
(bind-key "C-z" 'undo)
(bind-key "C-x C-u" 'undo)
#+END_SRC
*** Better Buffers
Kill better.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x k" 'bjm/kill-this-buffer)
#+END_SRC
Switch better.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x b" 'ido-switch-buffer)
#+END_SRC
Use ibuffer.
#+BEGIN_SRC emacs-lisp
(require 'ibuffer)
(bind-key "C-x C-b" 'ibuffer)
(autoload 'ibuffer "ibuffer" "List buffers." t)
#+END_SRC
*** Window Management
#+BEGIN_SRC emacs-lisp
(bind-key "C-x 1" 'delete-other-windows)
(bind-key "C-x 2" 'split-window-below)
(bind-key "C-x 3" 'split-window-right)
(bind-key "C-x 0" 'delete-window)
#+END_SRC
*** Transpose
***** Sentences and Paragraphs
Add aliases to do this easily.
#+BEGIN_SRC emacs-lisp
(defalias 'ts 'transpose-sentences)
(defalias 'tp 'transpose-paragraphs)
#+END_SRC
***** Characters
#+BEGIN_SRC emacs-lisp
(bind-key "C-r" 'transpose-chars)
#+END_SRC
*** Search
#+BEGIN_SRC emacs-lisp
(bind-key "C-s" 'swiper)
#+END_SRC
*** Unbind Fill Column
I never use this command but keep accidentally hitting it instead of =C-x C-f=.
#+BEGIN_SRC emacs-lisp
(unbind-key "C-x f")
#+END_SRC

** Word Count
Count org-wc.
#+BEGIN_SRC emacs-lisp
(use-package org-wc)
(bind-key "<C-f9>" 'org-wc-display)
(bind-key "C-c w" 'org-wc-display)
#+END_SRC
** Magit
#+BEGIN_SRC emacs-lisp
(bind-key "C-x g" 'magit-status)
#+END_SRC
** Org LaTeX Export
#+BEGIN_SRC emacs-lisp
(bind-key "C-c b" 'gm/org-latex-export)
#+END_SRC
** Dictionary
#+BEGIN_SRC emacs-lisp
(bind-key "C-c d" 'sdcv-search)
#+END_SRC
** Find Inbox
#+BEGIN_SRC emacs-lisp
(bind-key "C-c o" (lambda () (interactive) (find-file "~/org/inbox.org")))
#+END_SRC
** Complete Reload
#+BEGIN_SRC emacs-lisp
(bind-key "C-c r" 'gm/reload)
#+END_SRC
** Org Cliplink
Paste URL with extracted title as the description.
#+BEGIN_SRC emacs-lisp
(use-package org-cliplink)
(bind-key "C-c y" 'org-cliplink)
#+END_SRC
** Keychord
#+BEGIN_SRC emacs-lisp
(require 'key-chord)
(key-chord-mode 1)
#+END_SRC
*** Number Symbols
Eliminate the shift key for inputting symbols.
#+BEGIN_SRC emacs-lisp
(key-chord-define-global "1q" "!")
(key-chord-define-global "2w" "@")
(key-chord-define-global "3e" "#")
(key-chord-define-global "4r" "$")
(key-chord-define-global "5t" "%")
(key-chord-define-global "6y" "^")
(key-chord-define-global "6t" "^")
(key-chord-define-global "7y" "&")
(key-chord-define-global "8u" "*")
(key-chord-define-global "9i" "(")
(key-chord-define-global "0o" ")")
(key-chord-define-global "-p" "_")
#+END_SRC
*** God Mode
Easily enter god mode.
#+BEGIN_SRC emacs-lisp
(key-chord-define-global "jk" 'god-local-mode)
#+END_SRC
* Org
** Setup
We have to use ~require~ to get ~ox-hugo~ to work properly.
#+BEGIN_SRC emacs-lisp
(use-package org
  :init
  (require 'org)
  (require 'ox-latex)
  (use-package ox-hugo
    :ensure t
    :after ox)
  (require 'ox-hugo-auto-export)
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda)
         ("C-c c" . org-capture)
         ("M-h" . org-mark-element))
  :custom
  (org-directory "~/org/")
  (org-default-notes-file "~/org/inbox.org")
  (org-agenda-files '("~/org/inbox.org"
                      "~/org/gtd.org"
                      "~/org/tickler.org"
                      "~/org/notes.org"
                      "~/org/gcal.org"))
  (org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))
  (org-refile-targets '(("~/org/gtd.org" :maxlevel . 3)
                        ("~/org/someday.org" :level . 1)
                        ("~/org/tickler.org" :maxlevel . 2)
                        ("~/org/notes.org" :maxlevel . 2)))
  (org-capture-templates '(("a" "Appointment" entry
                            (file "~/org/gcal.org")
                            "* %i%? \n%^T\n")
                           ("t" "Todo [inbox]" entry
                            (file "~/org/inbox.org")
                            "* TODO %i%? \n:PROPERTIES:\n:CREATED: %U\n:END:")
                           ("T" "Tickler" entry
                            (file+headline "~/org/tickler.org" "Tickler")
                            "* %i%? \n:PROPERTIES:\n:CREATED: %U\n:END:")
                           ("j" "Journal" entry
                            (file+datetree "~/org/journal.org")
                            "** %^{Heading}\n:PROPERTIES:\n:CREATED: %U\n:END:")
                           ))
  :delight (org-indent-mode))
(setq org-hide-emphasis-markers t)
(setq org-startup-indented t)
(define-key org-mode-map (kbd "C-k") 'xah-cut-line-or-region)
#+END_SRC
*** Google Calendar
#+BEGIN_SRC emacs-lisp
(setq package-check-signature nil)
(use-package org-gcal
  :ensure t
  :config
  (setq org-gcal-client-id "980401579277-lhd730utipsj73s9d73qkkecrjjdlveo.apps.googleusercontent.com"
        org-gcal-client-secret "U4e1D8tH9TEC15sIeXKSqTE1"
        org-gcal-file-alist '(("gcmanohar001@gmail.com" . "~/org/gcal.org"))))
(add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync)))
#+END_SRC
** Prettifying
*** Org Bullets
#+BEGIN_SRC emacs-lisp
(use-package org-bullets)
(add-hook 'org-mode-hook
          (defun org-bullets-mode-enable ()
            (org-bullets-mode 1)))
#+END_SRC
*** Bullet List
Have lists begun by, for example, ~-~ look like a bullet-pointed list.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'org-mode
                        '(("^ *\\([-]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "‚Ä¢"))))))

#+END_SRC
** LaTeX
*** Export Settings
#+BEGIN_SRC emacs-lisp
(setq org-format-latex-options (plist-put org-format-latex-options :scale 1.0))
(setq org-highlight-latex-and-related '(latex))
(setq org-latex-to-pdf-process
 '("xelatex -interaction nonstopmode %f"
   "xelatex -interaction nonstopmode %f")) ;; for multiple passes
(setq org-export-with-smart-quotes t)
#+END_SRC
*** Cleverref
#+BEGIN_SRC emacs-lisp
(defun org-latex-ref-to-cref (text backend info)
  "Use \\cref instead of \\ref in latex export."
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string "\\\\ref{" "\\\\cref{" text)))

(add-to-list 'org-export-filter-final-output-functions
             'org-latex-ref-to-cref)
#+END_SRC
*** Autocomplete ~$~
#+BEGIN_SRC emacs-lisp
(defvar org-electric-pairs '((?$ . ?$) )) "Electric pairs for org-mode."
(defun dollar-add-electric-pairs ()
  (setq-local electric-pair-pairs (append electric-pair-pairs org-electric-pairs))
  (setq-local electric-pair-text-pairs electric-pair-pairs))
(add-hook 'org-mode-hook 'dollar-add-electric-pairs)
#+END_SRC
*** Don't Break Paragraph on Comments
Remove comments from org document when exporting to LaTeX.
#+BEGIN_SRC emacs-lisp
(defun delete-org-comments (backend)
  (loop for comment in (reverse (org-element-map (org-element-parse-buffer)
                                    'comment 'identity))
        do
        (setf (buffer-substring (org-element-property :begin comment)
                                (org-element-property :end comment))
              "")))
(add-hook 'org-export-before-processing-hook 'delete-org-comments)
#+END_SRC
*** Equation Auto Preview
Obtained from [[https://gist.github.com/cvcore/760008a4dfb2eadf42afdc9cf01ef979][Charles Wang]].
#+BEGIN_SRC emacs-lisp
(require 'ov)
(defvar cw/org-last-fragment nil
  "Holds the type and position of last valid fragment we were on. Format: (FRAGMENT_TYPE FRAGMENT_POINT_BEGIN)"
  )

(setq cw/org-valid-fragment-type
      '(latex-fragment
        latex-environment
        link))

(defun cw/org-curr-fragment ()
  "Returns the type and position of the current fragment available for preview inside org-mode. Returns nil at non-displayable fragments"
  (let* ((fr (org-element-context))
         (fr-type (car fr)))
    (when (memq fr-type cw/org-valid-fragment-type)
      (list fr-type
            (org-element-property :begin fr))))
  )

(defun cw/org-remove-fragment-overlay (fr)
  "Remove fragment overlay at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (goto-char fr-begin)
    (cond ((or (eq 'latex-fragment fr-type)
               (eq 'latex-environment fr-type))
           (let ((ov (loop for ov in (org--list-latex-overlays)
                           if
                           (and
                            (<= (overlay-start ov) (point))
                            (>= (overlay-end ov) (point)))
                           return ov)))
             (when ov
               (delete-overlay ov))))
          ((eq 'link fr-type)
           nil;; delete image overlay here?
           ))
    ))

(defun cw/org-preview-fragment (fr)
  "Preview org fragment at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (goto-char fr-begin)
    (cond ((or (eq 'latex-fragment fr-type) ;; latex stuffs
               (eq 'latex-environment fr-type))
           (when (cw/org-curr-fragment) (org-preview-latex-fragment))) ;; only toggle preview when we're in a valid region (for inserting in the front of a fragment)
          ((eq 'link fr-type) ;; for images
           (let ((fr-end (org-element-property :end (org-element-context))))
             (org-display-inline-images nil t fr-begin fr-end))))
    ))

(defun cw/org-auto-toggle-fragment-display ()
  "Automatically toggle a displayable org mode fragment"
  (and (eq 'org-mode major-mode)
       (let ((curr (cw/org-curr-fragment)))
         (cond
          ;; were on a fragment and now on a new fragment
          ((and
            ;; fragment we were on
            cw/org-last-fragment
            ;; and are on a fragment now
            curr
            ;; but not on the last one this is a little tricky. as you edit the
            ;; fragment, it is not equal to the last one. We use the begin
            ;; property which is less likely to change for the comparison.
            (not (equal curr cw/org-last-fragment)))

           ;; go back to last one and put image back, provided there is still a fragment there
           (save-excursion
             (cw/org-preview-fragment cw/org-last-fragment)
             ;; now remove current image
             (cw/org-remove-fragment-overlay curr)
             ;; and save new fragment
             )
           (setq cw/org-last-fragment curr))

          ;; were on a fragment and now are not on a fragment
          ((and
            ;; not on a fragment now
            (not curr)
            ;; but we were on one
            cw/org-last-fragment)
           ;; put image back on, provided that there is still a fragment here.
           (save-excursion
             (cw/org-preview-fragment cw/org-last-fragment))

           ;; unset last fragment
           (setq cw/org-last-fragment nil))

          ;; were not on a fragment, and now are
          ((and
            ;; we were not one one
            (not cw/org-last-fragment)
            ;; but now we are
            curr)
           ;; remove image
           (save-excursion
             (cw/org-remove-fragment-overlay curr)
             )
           (setq cw/org-last-fragment curr))
          ))))

(defvar gm/eq-preview nil)
(defun gm/toggle-equation-preview ()
  (interactive)
  (if gm/eq-preview
      (progn
        (remove-hook 'post-command-hook 'cw/org-auto-toggle-fragment-display)
        (message "Equation preview disabled."))
    (progn
      (add-hook 'post-command-hook 'cw/org-auto-toggle-fragment-display)
      (message "Equation preview enabled.")))
  (let ((var gm/eq-preview))
    (setq gm/eq-preview (not var))))
(bind-key "C-c p" 'gm/toggle-equation-preview)
#+END_SRC
*** CDLaTeX
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+END_SRC
*** Export Classes
**** Tufte-LaTeX
#+BEGIN_SRC emacs-lisp
(require 'ox-tufte-latex)
(require 'ox-extra)
#+END_SRC
***** Command Links
****** No Option
#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "latex" nil
 (lambda (path desc format)
   (when(eq format 'latex)
     (format "\\%s{%s}" path desc))))
#+END_SRC
****** One Option
#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "latex-opt" nil
 (lambda (path desc format)
   (when (eq format 'latex)
     (let* ((desc-list (split-string desc ";"))
            (opt (nth 1 desc-list))
            (arg (nth 0 desc-list)))
       (format "\\%s%s{%s}" path
               (if (equal "" opt) opt (format "[%s]" opt))
               arg)))))
#+END_SRC
***** Classes
****** Handout
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("tufte-handout"
               "\\documentclass[symmetric,nobib]{gm-tufte-handout}
   [NO-DEFAULT-PACKAGES]"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")))
#+END_SRC
****** Book
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("tufte-book"
               "\\documentclass[twoside,nobib]{tufte-book}
  [NO-DEFAULT-PACKAGES]"
               ("\\part{%s}" . "\\part*{%s}")
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")))
#+END_SRC
***** Biber
#+BEGIN_SRC emacs-lisp
(setq org-latex-pdf-process
      '("pdflatex -interaction nonstopmode -output-directory %o %f"
        "biber %b"
        "pdflatex -interaction nonstopmode -output-directory %o %f"
        "pdflatex -interaction nonstopmode -output-directory %o %f"))
#+END_SRC
***** Keyword Search
#+BEGIN_SRC emacs-lisp
(defun jk-org-kwds ()
  "parse the buffer and return a cons list of (property . value)
from lines like:
,#+PROPERTY: value"
  (org-element-map (org-element-parse-buffer 'element) 'keyword
    (lambda (keyword) (cons (org-element-property :key keyword)
                            (org-element-property :value keyword)))))

(defun jk-org-kwd (KEYWORD)
  "get the value of a KEYWORD in the form of #+KEYWORD: value"
  (cdr (assoc KEYWORD (jk-org-kwds))))
#+END_SRC
**** Assignment
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ox-latex
  (add-to-list 'org-latex-classes
               '("assignment"
                 "\\documentclass[12pt]{article}
\\usepackage{uts-assignment}
\\renewcommand{\\maketitle}{}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC
*** Mass Export
#+BEGIN_SRC emacs-lisp
(defun org-export-headlines-to-pdf ()
  "Export all subtrees that are *not* tagged with :noexport: to
separate files.

Subtrees that do not have the :EXPORT_FILE_NAME: property set
are exported to a filename derived from the headline text."
  (interactive)
  (save-buffer)
  (let ((modifiedp (buffer-modified-p)))
    (save-excursion
      (goto-char (point-min))
      (goto-char (re-search-forward "^*"))
      (set-mark (line-beginning-position))
      (goto-char (point-max))
      (org-map-entries
       (lambda ()
         (let ((export-file (org-entry-get (point) "EXPORT_FILE_NAME")))
           (unless export-file
             (org-set-property
              "EXPORT_FILE_NAME"
              (replace-regexp-in-string " " "_" (nth 4 (org-heading-components)))))
           (deactivate-mark)
           (org-latex-export-to-latex nil t)
           (unless export-file (org-delete-property "EXPORT_FILE_NAME"))
           (set-buffer-modified-p modifiedp)))
       "-noexport" 'region-start-level))))

(defun gm/org-latex-export ()
  (interactive)
  (save-excursion
    (search-backward "EXPORT_FILE_NAME")
    (org-narrow-to-subtree)
    (org-export-headlines-to-pdf)
    (widen)))
#+END_SRC
* TeX
** AUCTeX
#+BEGIN_SRC emacs-lisp
(use-package auctex
  :defer t
  :ensure t)
(require 'tex-site)
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq TeX-PDF-mode t)
(setq preview-auto-cache-preamble t)
(setq TeX-source-correlate-method 'synctex)
(add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
(add-hook 'LaTeX-mode-hook 'visual-line-mode)
(add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
(add-hook 'LaTeX-mode-hook 'TeX-fold-mode)
(defun turn-on-outline-minor-mode ()
  (outline-minor-mode 1))
(add-hook 'LaTeX-mode-hook 'turn-on-outline-minor-mode)
(add-hook 'latex-mode-hook 'turn-on-outline-minor-mode)
(setq outline-minor-mode-prefix "\C-c \C-o") ; Or something else
(setq LaTeX-eqnarray-label "eq"
      LaTeX-equation-label "eq"
      LaTeX-figure-label "fig"
      LaTeX-table-label "tab"
      LaTeX-myChapter-label "chap"
      TeX-auto-save t
      TeX-newline-function 'reindent-then-newline-and-indent
      TeX-parse-self t
      LaTeX-section-hook
      '(LaTeX-section-heading
        LaTeX-section-title
        LaTeX-section-toc
        LaTeX-section-section
        LaTeX-section-label))
#+END_SRC
*** Prettifying
Don't make super and subscripts smaller.
#+BEGIN_SRC emacs-lisp
(setq font-latex-fontify-script nil)
#+END_SRC
** Electric Dollars and Parens
Insert dollar signs electrically.
#+BEGIN_SRC emacs-lisp
(add-hook 'TeX-mode-hook
	      (lambda () (set (make-variable-buffer-local 'TeX-electric-math)
			              (cons "$" "$"))))
(add-hook 'LaTeX-mode-hook
	      (lambda () (set (make-variable-buffer-local 'TeX-electric-math)
			              (cons "$" "$"))))
#+END_SRC
** CDLaTeX
I use this package to easily insert math characters.
#+BEGIN_SRC emacs-lisp
(use-package cdlatex)
#+END_SRC
Automatically turn on when using LaTeX.
#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook 'turn-on-cdlatex)
#+END_SRC
* Mail
Set up the requirements.
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
(require 'smtpmail)
(require 'mu4e)
#+END_SRC
SMTP for sending emails. The =stream-type= is important because Stanford's email
servers require that outgoing email use TLS encryption.
#+BEGIN_SRC emacs-lisp
(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-debug-info t
      smtpmail-stream-type 'starttls
      smtpmail-default-smtp-server "smtp.stanford.edu"
      smtpmail-smtp-server "smtp.stanford.edu"
      smtpmail-smtp-service 587)
#+END_SRC
Folders and keybinds for accessing those folders.
#+BEGIN_SRC emacs-lisp
(setq mu4e-maildir (expand-file-name "~/email/mbsyncmail"))
(setq mu4e-drafts-folder "/Drafts"
      mu4e-sent-folder "/Sent Items"
      mu4e-trash-folder "/Trash")
(setq mu4e-maildir-shortcuts
      '(("/INBOX" . ?i)
        ("/Sent Items" . ?s)
        ("/Deleted Items" . ?t)
        ("/Drafts" . ?d)
        ("/Archived" . ?a)))
#+END_SRC
Utilities and improvements of receiving and viewing
#+BEGIN_SRC emacs-lisp
(setq mu4e-get-mail-command "mbsync -c ~/.mbsyncrc uni"
      mu4e-html2text-command "w3m -T text/html"
      mu4e-update-interval 120
      mu4e-headers-auto-update t
      mu4e-compose-signature-auto-include nil)
(setq mu4e-show-images t)
(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))
(setq mu4e-reply-to-address "gmanohar@stanford.edu"
      user-mail-address "gmanohar@stanford.edu"
      user-full-name  "Gautam Manohar")
(setq mu4e-sent-messages-behavior 'delete)
(add-hook 'mu4e-compose-mode-hook
          (defun my-do-compose-stuff ()
            "My settings for message composition."
            (set-fill-column 80)
            (flyspell-mode)))
#+END_SRC
* Snippets
** Load Snippets
#+BEGIN_SRC emacs-lisp
(setq yas-snippet-dirs '("~/.emacs.d/snippets"))
(use-package yasnippet
  :diminish (yas-minor-mode))
(yas-global-mode 1)
#+END_SRC
** SPC Expansion
Use SPC instead of TAB to expand snippets.
#+BEGIN_SRC emacs-lisp
(define-key yas-minor-mode-map (kbd "<tab>") nil)
(define-key yas-minor-mode-map (kbd "TAB") nil)
(define-key yas-minor-mode-map (kbd "SPC")
  (or (bound-and-true-p yas-maybe-expand) #'yas-expand))
#+END_SRC
** Vim-like Ultisnips
Use =texmathp= to tell if you are in math mode.
#+BEGIN_SRC emacs-lisp
(require 'texmathp)
#+END_SRC
Using a hydra, I setup automatic expansion of yasnippets; when a leader key is
pressed, that key is inserted, but if the next key of a defined sequence is
pressed, the leader key is erased and the snippet is expanded.
#+BEGIN_SRC emacs-lisp
(require 'hydra)
#+END_SRC
To automate the generation of hydras, I use a data structure called a prefix
tree, also known as a tree.
#+BEGIN_SRC emacs-lisp
(require 'strie)
#+END_SRC
*** Helper Functions
**** Delete n Characters
Delete n characters before the point.
#+BEGIN_SRC emacs-lisp
(defun gm/delete-chars (n)
  (dotimes (i n) (delete-char -1)))
#+END_SRC
**** Last n Characters Before Point
Return the last n characters before the point.
#+BEGIN_SRC emacs-lisp
(defun gm/last-n-chars (n)
  (buffer-substring-no-properties (- (point) n) (point)))
#+END_SRC
**** Expand Snippet
#+BEGIN_SRC emacs-lisp
(defun gm/expand-snippet (name)
  (yas-expand-snippet (yas-lookup-snippet name)))
#+END_SRC
**** Check Correct Prefix
Most of my snippets for math mode are longer than two characters. In this case,
I need to check that the correct characters precede the typed ones before
executing a snippet. For example, I should only execute the "sin" snippet after
typing "in" if the character "s" precedes "in." This function returns true if
the given string, not including the last character, precedes the point.
#+BEGIN_SRC emacs-lisp
(defun gm/prefix-before-point (key)
  (let ((len (length key)))
    (equal (substring key 0 (1- len))
           (gm/last-n-chars (1- len)))))
#+END_SRC
**** Math Mode Snippet
#+BEGIN_SRC emacs-lisp
(defun gm/snippet (key snippet)
  (let ((len (length key)))
    (if (and (eq major-mode 'org-mode) (and (texmathp) (gm/prefix-before-point key)))
        (progn
          (gm/delete-chars (- len 1))
          (gm/expand-snippet snippet))
      (insert (substring key (- len 1) len)))))
#+END_SRC
**** Generate Snippets
I wrote this code to reduce the amount of redundant code needed to set up the snippets.
This function is a work in progress.

This macro is the main helper.
#+BEGIN_SRC emacs-lisp
(defmacro gm/math-hydra (name)
  `(defhydra ,(intern (concat "math-" name))
     (:color blue :body-pre (insert ,(substring name (1- (length name)) (length name))) :base-map (make-sparse-keymap) :idle 1.0)
     ,@(loop for x in
             ;; for each partial string of trie
             ;; (for example <c, cc, ce, cei, ceil> and so on)
             ;; loop through completion candidates that are one character longer
             (loop for candidate in (strie-complete gm/math-trie name) if (= (length candidate) (1+ (length name)))
                   collect candidate)
             ;; expand if the partial string has a snippet expansion
             ;; otherwise, proceed to next step in trie traversal
             collect (if (strie-get gm/math-trie x)
                         (list (substring x (1- (length x)) (length x)) `(gm/snippet ,x ,(strie-get gm/math-trie x)) (strie-get gm/math-trie x))
                       (list (substring x (1- (length x)) (length x)) (intern (concat "math-" x "/body" )) "proceed")))))
#+END_SRC
Setting up the data structures.
#+BEGIN_SRC emacs-lisp
(defun gm/math-setup ()
  (setq gm/math-trie (strie-new))
  (loop for (key . value) in gm/math-snippets
        do (strie-add gm/math-trie key value))
  (loop for (key . value) in gm/math-snippets
        do (loop for i from 1 to (1- (length key))
                 do (strie-add gm/math-trie (substring key 0 i) nil)))
  (loop for name in (strie-bfs-keys gm/math-trie) if (not (assoc name gm/math-snippets))
        collect (eval (macroexpand `(gm/math-hydra ,name)))))
(add-hook 'org-mode-hook 'gm/math-setup)
#+END_SRC
*** Math Snippets
#+BEGIN_SRC emacs-lisp
(setq gm/math-snippets
      '(("sq" . "sqrt")
        ("nsq" . "nsqrt")
        ("sr" . "squared")
        ("list" . "list")
        ("cc" . "subset")
        ("cb" . "cubed")
        ("dd" . "derivative-one-term")
        ("pdd" . "partial")
        ("part" . "partial")
        ("dv" . "derivative")
        ("pdv" . "partial-derivative")
        ("norm" . "norm")
        ("lr9" . "parentheses")
        ("lr[" . "brackets")
        ("lr{" . "set")
        ("set" . "set")
        ("int" . "integral")
        ("iint" . "iintegral")
        ("oint" . "ointegral")
        ("dint" . "dintegral")
        ("inv" . "inverse")
        ("inn" . "in")
        ("!>" . "maps-to")
        ("=>" . "implies")
        ("&&" . "split-equals")
        ("lim" . "limit")
        ("ceil" . "ceiling")
        ("fl" . "floor")
        ("dim" . "dim")
        ("im" . "image")
        ("ker" . "kernel")
        ("span" . "span")
        ("neq" . "neq")
        ("sin" . "sin")
        ("asin" . "asin")
        ("cos" . "cos")
        ("acos" . "acos")
        ("tan" . "tan")
        ("atan" . "atan")
        ("cot" . "cot")
        ("cot" . "acot")
        ("sec" . "sec")
        ("sum" . "sum")
        ("pairsum" . "pairsum")
        ("ps" . "pairsum")
        ("fun" . "function")
        ("le" . "less-than")
        ("ge" . "greater-than")
        ("xx" . "times")
        ("log" . "log")
        ("bol" . "bol")
        ("oo" . "infinity")
        ("o+" . "oplus")
        ("star" . "star")
        ("frac" . "frac")
        ("abs" . "abs")
        ("nabl" . "nabla")
        ("RR" . "real")
        ("QQ" . "rational")
        ("CC" . "complex")
        ("NN" . "natural")
        ("ZZ" . "integers")
        ("LL" . "cal-L")
        ("MM" . "cal-M")))
#+END_SRC
*** Math Keybindings
Haven't figured out a way to automate this yet. It's not a big deal, as it won't
change that often.
#+BEGIN_SRC emacs-lisp
(define-conditional-key org-mode-map "a" 'math-a/body (texmathp))
(define-conditional-key org-mode-map "b" 'math-b/body (texmathp))
(define-conditional-key org-mode-map "c" 'math-c/body (texmathp))
(define-conditional-key org-mode-map "d" 'math-d/body (texmathp))
(define-conditional-key org-mode-map "f" 'math-f/body (texmathp))
(define-conditional-key org-mode-map "g" 'math-g/body (texmathp))
(define-conditional-key org-mode-map "i" 'math-i/body (texmathp))
(define-conditional-key org-mode-map "k" 'math-k/body (texmathp))
(define-conditional-key org-mode-map "l" 'math-l/body (texmathp))
(define-conditional-key org-mode-map "n" 'math-m/body (texmathp))
(define-conditional-key org-mode-map "o" 'math-o/body (texmathp))
(define-conditional-key org-mode-map "p" 'math-p/body (texmathp))
(define-conditional-key org-mode-map "s" 'math-s/body (texmathp))
(define-conditional-key org-mode-map "t" 'math-t/body (texmathp))
(define-conditional-key org-mode-map "x" 'math-x/body (texmathp))
(define-conditional-key org-mode-map "!" 'math-!/body (texmathp))
(define-conditional-key org-mode-map "=" 'math-=/body (texmathp))
(define-conditional-key org-mode-map "&" 'math-&/body (texmathp))
(define-conditional-key org-mode-map "C" 'math-C/body (texmathp))
(define-conditional-key org-mode-map "L" 'math-L/body (texmathp))
(define-conditional-key org-mode-map "M" 'math-M/body (texmathp))
(define-conditional-key org-mode-map "N" 'math-N/body (texmathp))
(define-conditional-key org-mode-map "Q" 'math-Q/body (texmathp))
(define-conditional-key org-mode-map "R" 'math-R/body (texmathp))
(define-conditional-key org-mode-map "Z" 'math-Z/body (texmathp))
#+END_SRC
*** Math Symbols
#+BEGIN_SRC emacs-lisp
(defhydra hydra-semicolon-a (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-b/body "Level 2")
  ("SPC" (insert "; ") ";")
  ("a" (insert "\\alpha") "Œ±")
  ("A" (insert "\\forall ") "‚àÄ")
  ("b" (insert "\\beta") "Œ≤")
  ("C" (insert "\\mathbb{C}") "‚ÑÇ")
  ("d" (insert "\\delta") "Œ¥")
  ("D" (insert "\\Delta") "Œî")
  ("e" (insert "\\epsilon") "Œµ")
  ("E" (insert "\\exists ") "‚àÉ")
  ("f" (insert "\\varphi") "œÜ")
  ("F" (insert "\\Phi") "Œ¶")
  ("g" (insert "\\gamma") "Œ≥")
  ("G" (insert "\\Gamma") "Œì")
  ("h" (insert "\\eta") "Œ∑")
  ("k" (insert "\\kappa") "Œ∫")
  ("l" (insert "\\lambda") "Œª")
  ("L" (insert "\\Lambda") "Œõ")
  ("m" (insert "\\mu") "¬µ")
  ("n" (insert "\\nu") "ŒΩ")
  ("N" (insert "\\nabla ") "‚àá")
  ("o" (insert "\\omega") "œâ")
  ("O" (insert "\\Omega") "Œ©")
  ("p" (insert "\\pi") "œÄ")
  ("P" (insert "\\Pi") "Œ†")
  ("q" (insert "\\theta") "Œ∏")
  ("Q" (insert "\\mathbb{Q}") "‚Ñö")
  ("r" (insert "\\rho") "œÅ")
  ("R" (insert "\\mathbb{R}") "‚Ñù")
  ("s" (insert "\\sigma") "œÉ")
  ("t" (insert "\\tau") "œÑ")
  ("u" (insert "\\upsilon") "œÖ")
  ("U" (insert " \\cup ") "‚à™")
  ("w" (insert "\\xi") "Œæ")
  ("W" (insert "\\Xi") "Œû")
  ("x" (insert "\\chi") "œá")
  ("y" (insert "\\psi") "œà")
  ("Y" (insert "\\Psi") "Œ®")
  ("z" (insert "\\zeta") "Œ∂")
  ("Z" (insert "\\mathbb{Z}") "‚Ñ§")
  ("0" (insert " \\emptyset") "‚àÖ")
  ("8" (insert "\\infinity") "‚àû")
  ("!" (insert "\\neg") "¬¨")
  ("*" (insert "\\star") "‚ãÜ")
  ("\\" (insert "\\setminus ") "‚àñ")
  ("'" (insert "\\prime ") "‚Ä≤")
  ("," (insert ",\\ldots,") ".")
  ("." (insert " \\cdot ") "¬∑"))

(defhydra hydra-semicolon-b (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-a/body "base")
  (" " (insert "; " "semicolon"))
  ("e" (insert "\\varepsilon") "Œµ")
  ("f" (insert "\\phi") "œÜ")
  ("F" (insert "\\mathbb{F}") "ùîΩ")
  ("l" (insert "\\ell") "‚Ñì")
  ("q" (insert "\\Theta") "Œò")
  ("r" (insert "\\varrho") "œÅ")
  ("U" (insert "\\cap ") "‚à©")
  ("x" (insert " \\times ") "√ó")
  ("." (insert " \\cdots ") "¬∑¬∑¬∑")
  ("-" (gm/snippet "" "conjugate") "-"))

(define-conditional-key org-mode-map ";" 'hydra-semicolon-a/body (texmathp))
#+END_SRC
