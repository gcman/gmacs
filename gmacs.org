#+TITLE: My Emacs Configuration
#+PROPERTY: header-args :results silent :tangle gmacs.el
* Starting Up
** Fixing the UI
:PROPERTIES:
:header-args: :tangle no
:END:
Emacs ships with a set of pretty strange defaults. The UI is the first thing we
see when we open Emacs, so it better not look ugly. We're going to configure
part of the UI outside Emacs entirely, by editing the =~/.Xresources=.

This kills the ugly parts of the UI before they are born. This is slightly
faster than disabling them within Emacs, but it offers less flexibility. For
example, if Emacs fails to start up properly, you are possibly left staring at a
chimera of an editor, with default font colours but themed background
colours. Because the font is about the same shade as the background, this makes
for some very fun times debugging.

After editing =.Xresources=, remember to reload it with =xrdb merge ~/.Xresources=.
*** Bars
I never use menu bars, tool bars, or scroll bars in Emacs.
#+BEGIN_SRC conf
Emacs.menuBar: off
Emacs.toolBar: off
Emacs.verticalScrollBars: off
#+END_SRC
*** Cursor Blinking
In earlier versions of Emacs, the cursor would blink ten or so times, then
suddenly stop. This got annoying quickly.
#+BEGIN_SRC conf
Emacs.cursorBlink: off
#+END_SRC
*** Background Colour
Before a theme is initialized, the default background colour that Emacs displays
is white. However, my default theme is a dark theme (Solarized Dark). If I were
to change the background colour after Emacs starts, the screen would flash as it
changes colour. And so I set the default background and foreground colour to be
that of Solarized Dark.
#+BEGIN_SRC conf
Emacs.background: #002b36
Emacs.foreground: #839496
#+END_SRC
The last thing left that is visible throughout startup is the modeline. It
took a bit of Internet sleuthing to figure out how to set this, but here it is.
#+BEGIN_SRC conf
Emacs.mode-line.attributeForeground: #93a1a1
Emacs.mode-line.attributeBackground: #002b36
Emacs.mode-line.attributeBox: (:line-width 1 :color "#073642")
#+END_SRC
*** Default Font
I often experiment with fonts during an Emacs session, so I set up an easy way
to change that [[*Font Face][here]]. On startup, though, I want something neutral, so I go with
Hack.
#+BEGIN_SRC conf
Emacs.font: Hack-10
#+END_SRC
** Early Init
Here's some cutting edge technology. Emacs 27 introduced =early-init.el=, which
is run before =init.el=, before package initialization.

Package initialization occurs automatically, before =user-init-file= is loaded,
but after =early-init-file=. As we'll see later, we can handle package
initialization ourselves, so there's no need for Emacs to do it first.
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+END_SRC
** =init.el=
The main entry point into GMACS. First, we remove some features that would make
startup take longer and aren't that useful.
#+BEGIN_SRC emacs-lisp :tangle init.el
(advice-add #'display-startup-echo-area-message :override #'ignore)
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message user-login-name
      inhibit-default-init t
      initial-major-mode 'fundamental-mode
      initial-scratch-message nil)
#+END_SRC
We either load the byte-compiled GMACS configuration file or tangle and load
the GMACS literate config file (you're reading it!) written in Org Mode.
#+BEGIN_SRC emacs-lisp :tangle init.el
(let ((file-name-handler-alist nil)
      (orgfile (expand-file-name "gmacs.org" user-emacs-directory))
      (elfile (expand-file-name "gmacs.el" user-emacs-directory))
      (elcfile (expand-file-name "gmacs.elc" user-emacs-directory))
      (personalfile (expand-file-name "personal.el" user-emacs-directory)))
  (if (file-exists-p elcfile)
      (load-file elcfile)
    (if (or (not (file-exists-p elfile))
            (file-newer-than-file-p orgfile elfile))
        (progn
          (require 'org)
          (org-babel-load-file orgfile))
      (load-file elfile)))
  (when (file-exists-p personalfile)
    (load-file personalfile)))
#+END_SRC
** Initialization Settings
Enable lexical binding.
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC
Always load up a server when opening Emacs.
#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC
I was inspired to implement the following optimizations in GMACS thanks to
[[https://github.com/nilcons/emacs-use-package-fast][nilcons/emacs-use-package-fast]]. During startup, we make the garbage collection
threshold very high. [[*Garbage Collection][After startup]], we manage garbage collection with a package.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold #x40000000)
#+END_SRC
We increase these so that we don't exceed recursion limits unless there is some
kind of infinite loop.
#+BEGIN_SRC emacs-lisp
(setq max-lisp-eval-depth 50000
      max-specpdl-size 10000)
#+END_SRC
Now we prevent loading double buffers, which reduces stuttering.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(inhibit-double-buffering . t))
#+END_SRC
Silence some common warnings from the byte-compiler.
#+BEGIN_SRC emacs-lisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+END_SRC
Let the user know how quickly GMACS started.
#+BEGIN_SRC emacs-lisp
(defun gm/startup-time ()
  (interactive)
  (message "GMACS ready in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done))

(add-hook 'after-init-hook #'gm/startup-time)
#+END_SRC
** Directories and File Locations
We define a few custom directories to satisfy my own wishes for how things
should be named and to speed up the package initialization process by doing it
ourselves, rather than relying on =package-initialize=. Note that the whole thing
is wrapped in a byte-compile block.

We make the directories if they don't exist by iterating over a list. This
method makes it easy for to extend to more directories if needed.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar gmacs-packages-dir (concat user-emacs-directory "packages/")
    "Where package.el and elpa plugins (and their caches) are stored.")

  (defvar gmacs-custom-dir (concat user-emacs-directory "elisp/")
    "Where custom lisp files are stored")

  (defvar gmacs-cache-dir (concat user-emacs-directory "cache/")
    "Where temporary files that could be deleted without anything
    terrible happening are stored.")

  (dolist (dir (list gmacs-packages-dir
                     gmacs-custom-dir
                     gmacs-cache-dir))
    (unless (file-directory-p dir)
      (make-directory dir t))))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defvar gm/user nil)
#+END_SRC
I put custom variables outside of my =init.el= file.
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file) (load custom-file))
#+END_SRC
Make a variable for personal settings.
** Setup Packages
We're going to use a custom package directory, so we need to trick Emacs into
thinking it has initialized packages by setting =package--init-file-ensured= to =t=.
Also, we don't enable packages at startup, because we will let =use-package=
intelligently defer and handle package loading.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq load-prefer-newer t
        package-user-dir gmacs-packages-dir
        package--init-file-ensured t
        package-enable-at-startup nil))
#+END_SRC
We set the =load-path= ourselves. This will be faster than letting
=package-intialize= handle it, because we only add directories we know are from
packages. This way, we don't need to search all third party paths every time we
require a file. We'll also store custom or third-party Emacs Lisp files in
=gmacs-custom-dir=, so we add that to the =load-path=.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t)))
  (add-to-list 'load-path gmacs-custom-dir))
#+END_SRC
Our next step is to load =package.el=. We add our package repositories "melpa" and
"gnu," because Emacs' default list of packages is so conservative. Then we need
to initialize the packages and make sure that =use-package= is installed if its
missing. Finally, we tell =use-package= to always install missing packages.
Otherwise, an error would be thrown when a package is missing.

We use the following package archives.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref pack-arch
(setq package-archives
        '(("melpa" . "https://melpa.org/packages/")
          ("gnu" . "https://elpa.gnu.org/packages/")
          ("org" . "http://orgmode.org/elpa/")))
#+END_SRC
Note that this whole process is only run when the file is byte-compiled. This
means that by the time the code is actually evaluated, the =use-package= macro has
been expanded, so the package is not needed anymore. As such, we can do all the
expensive and time-consuming work of getting the packages ready before Emacs has
even started, during byte-compilation. If this config has not been manually
byte-compiled, Emacs will initialize packages on startup as usual.
#+BEGIN_SRC emacs-lisp :noweb no-export
(eval-when-compile
  (require 'package)
  <<pack-arch>>
  (package-initialize)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package))
#+END_SRC
Get =use-package= to always defer loading packages until they are actually needed.
This reduces startup time significantly. We're doing this now, before
=use-package= is even loaded, because otherwise it won't help us when the code
that loads =use-package= is evaluated upon byte-compilation.
#+BEGIN_SRc emacs-lisp
(setq use-package-always-defer t
      use-package-verbose t
      use-package-always-ensure t)
#+END_SRC
We also require =diminish= and =bind= because I often use these keywords within
=use-package= declarations.
#+BEGIN_SRC emacs-lisp
(use-package bind-key)
(use-package diminish)
#+END_SRC
*** Common Libraries
We load some packages that I use throughout my configuration.
#+BEGIN_SRC emacs-lisp
(use-package async :commands (async-start))
(use-package s :demand t)
(use-package dash :demand t :config (dash-enable-font-lock))
(eval-when-compile (require 'cl-lib))
#+END_SRC
* General Configuration
** Macros
Elisp macros. =after!= and =lambda!= are from the popular DOOM! Emacs
configuration. The documentation on these will be sparse, because the docstrings
do an excellent job of explaining what's going on.
*** after!
#+BEGIN_SRC emacs-lisp
(defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms)))
#+END_SRC
*** lambda!
#+BEGIN_SRC emacs-lisp
(defmacro lambda! (&rest body)
  "A shortcut for inline interactive lambdas."
  (declare (doc-string 1))
  `(lambda () (interactive) ,@body))
#+END_SRC
*** Conditional Keybindings
Obtained from [[http://endlessparentheses.com/define-context-aware-keys-in-emacs.html][Endless Parentheses]].
#+BEGIN_SRC emacs-lisp
(defmacro define-conditional-key (keymap key def &rest body)
  "In KEYMAP, define key sequence KEY as DEF conditionally.
This is like `define-key', except the definition
\"disappears\" whenever BODY evaluates to nil."
  (declare (indent 3)
           (debug (form form form &rest sexp)))
  `(define-key ,keymap ,key
     '(menu-item
       ,(format "maybe-%s" (or (car (cdr-safe def)) def))
       nil
       :filter (lambda (&optional _)
                 (when ,(macroexp-progn body)
                   ,def)))))
#+END_SRC

** User Interface
Show off the title.
#+BEGIN_SRC emacs-lisp
(setq frame-title-format "GMACS")
#+END_SRC
*** Cursor
I prefer a box cursor to a bar cursor. Setting =x-stretch-cursor= means that this
bar will stretch to the full width of the character it is on. For example, on a
tab (evil tabs!), the cursor will look as wide as a tab.
#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (setq-default cursor-type 'box))
(setq x-stretch-cursor t)
#+END_SRC
**** Beacon Mode
Never lose your cursor again. This package lights up your cursor when the
screen/cursor position is refactored. It's much more useful than it sounds.
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :defer 2
  :config (beacon-mode 1)
  :custom (beacon-color "#b58900"))
#+END_SRC
*** Bells
Visual, not audible bells.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(setq visible-bell t)
#+END_SRC
*** Modeline
The =smart-mode-line= package comes with some useful items on the modeline, as
well as colour coding. Some interesting features (which I set in
=sml/replacer-regexp-list=) is shortening features. Another useful thing is that
minor modes are displayed.
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :defer 1
  :config (sml/setup))
#+END_SRC
What time is it, Mr. Emacs?
#+BEGIN_SRC emacs-lisp
(display-time-mode 1)
(setq display-time-format "%l:%M%p")
#+END_SRC
=line-number-mode= mode displays the current line number in the modeline. Except
when there is a line Emacs decides is too long. In that case, all you see in the
modeline is =??=. See [[https://emacs.stackexchange.com/questions/3824/what-piece-of-code-in-emacs-makes-line-number-mode-print-as-line-number-i][this question]] on Emacs SE for a workaround.
#+BEGIN_SRC emacs-lisp
(setq line-number-display-limit-width 10000)
#+END_SRC
Given that we're showing the line number in the modeline, it's often nice to
also have the column number.
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
#+END_SRC
*** Scrolling
There are two types of scrolling in Emacs: keyboard scrolling and mouse
scrolling. Both of them are quite jarring out of the box and make the screen
lurch around. Let's fix keyboard scrolling.
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 1
      scroll-step 1
      scroll-conservatively 10000
      scroll-preserve-screen-position 1)
#+END_SRC
And make mouse scrolling smoother.
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed t) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse t) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
(setq scroll-margin 3) ;; give the cursor some buffer room before scrolling window
#+END_SRC
*** Theme
I use the popular Solarized Light/Dark themes.
#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :demand t
  :config (load-theme 'solarized-dark))
#+END_SRC
I switch between the light and dark variants depending on my surroundings. If I
am in a brightly lit room, I prefer to use the light theme, because the dark
theme allows too much screen glare. At night (really, at most times, but in
particular at night) I prefer the dark theme, which, unsurprisingly, spits less
light into my eyes.

The way I switch themes is, admittedly, somewhat hacky. I set a boolean (by
default true) that is true if the active theme is dark, false if light. What can
I say? I prefer the dark side. Then my switch function toggles that value and
changes the theme and the corresponding colours for =pdf-view-mode=. I like to
view my PDFs not in black and white, but in my theme's colours. To make sure
everything looks right, including the colours in PDFs and the asterisks
for headlines in Org Mode (I hide them with =org-bullets-mode= but one of them
comes back when I switch themes, for some reason), I refresh all open buffers.
#+BEGIN_SRC emacs-lisp
(defvar gm/theme 'dark)
(defun gm/switch-theme ()
  (interactive)
  (if (eq gm/theme 'dark)
      (progn
        (load-theme 'solarized-light)
        (after! pdf-tools (setq pdf-view-midnight-colors '("#839496" . "#fdf6e3")))
        (setq gm/theme 'light))
    (load-theme 'solarized-dark)
    (setq pdf-view-midnight-colors '("#839496" . "#002b36"))
    (setq gm/theme 'dark))
  (modi/revert-buffers))
#+END_SRC
**** Font Face
I change my fonts a lot, so I made it easier to set a font.
#+BEGIN_SRC emacs-lisp
(defun gm/switch-font ()
  (interactive)
  (let ((font (ivy-completing-read "Choose a font: "
                                   (delete-dups (font-family-list)))))
    (set-face-attribute 'default nil :font font)))
#+END_SRC
I also like using Palatino here.
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(variable-pitch ((t (:family "Source Sans Pro" :height 115)))))
#+END_SRC
I have experienced problems with certain math characters being displayed with a
font from the TeX Gyre family, which causes the line width to be very high. I
set the default font for characters in the "Mathematical Alphanumeric Symbols"
block in Unicode to Symbola. I got the Symbola font from the =ttf-ancient-fonts=
package on the AUR.
#+BEGIN_SRC emacs-lisp
(defvar gm/unicode-font "Symbola")
#+END_SRC
#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default" '(#x1d400 . #x1d7ff) gm/unicode-font)
(set-fontset-font "fontset-default" '(#x2200 . #x22ff) gm/unicode-font)
#+END_SRC
I do something similar for my =org-ellipsis= character (=⬎=); here, though, I just
prefer how this font draws the character.
#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default" '(#x2b0e . #x2b0e) gm/unicode-font)
#+END_SRC
I also include other miscellaneous characters.
#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default" '(#x211c . #x211c) gm/unicode-font) ;; real part ℜ
(set-fontset-font "fontset-default" '(#x2111 . #x2111) gm/unicode-font) ;; imaginary part ℑ
(set-fontset-font "fontset-default" '(#x2113 . #x2113) gm/unicode-font) ;; ell ℓ
(set-fontset-font "fontset-default" '(#x2118 . #x2118) gm/unicode-font) ;; Weierstrass p ℘
(set-fontset-font "fontset-default" '(#x2135 . #x2135) gm/unicode-font) ;; aleph ℵ
#+END_SRC
**** Syntax Highlighting
I want syntax highlighting everywhere...
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode 1)
#+END_SRC
except in massive buffers, where it probably wouldn't be that useful (syntax
highlighting doesn't help you read a CSV file with thousands of lines) and would
definitely slow things down. In such buffers I also remove line numbers.
#+BEGIN_SRC emacs-lisp
(defun buffer-too-big-p ()
  (or (> (buffer-size) (* 5000 80))
      (> (line-number-at-pos (point-max)) 5000)))

(defun gm/big-buffer-setup ()
  (when (buffer-too-big-p)
              (nlinum-relative-mode -1)
              (font-lock-mode -1)))

(add-hook 'prog-mode-hook #'gm/big-buffer-setup)
#+END_SRC
Normally, I want the opening and closing parentheses highlighted. I used to set
=show-paren-style= to =expression=, but all that highlighting was not really
necessary. A great idea from [[https://with-emacs.com/posts/editing/show-matching-lines-when-parentheses-go-off-screen/][(with-emacs]] is to advise the function that shows
matching parentheses to display an overlay with the appropriate matching line
when it is off-screen.
#+BEGIN_SRC emacs-lisp
(let ((ov nil)) ; keep track of the overlay
  (advice-add
   #'show-paren-function
   :after
   (defun show-paren--off-screen+ (&rest _args)
     "Display matching line for off-screen paren."
     (when (overlayp ov)
       (delete-overlay ov))
     ;; check if it's appropriate to show match info,
     ;; see `blink-paren-post-self-insert-function'
     (when (and (overlay-buffer show-paren--overlay)
                (not (or cursor-in-echo-area
                         executing-kbd-macro
                         noninteractive
                         (minibufferp)
                         this-command))
                (and (not (bobp))
                     (memq (char-syntax (char-before)) '(?\) ?\$)))
                (= 1 (logand 1 (- (point)
                                  (save-excursion
                                    (forward-char -1)
                                    (skip-syntax-backward "/\\")
                                    (point))))))
       ;; rebind `minibuffer-message' called by
       ;; `blink-matching-open' to handle the overlay display
       (cl-letf (((symbol-function #'minibuffer-message)
                  (lambda (msg &rest args)
                    (let ((msg (apply #'format-message msg args)))
                      (setq ov (display-line-overlay+
                                (window-start) msg ))))))
         (blink-matching-open))))))

(defun display-line-overlay+ (pos str &optional face)
  "Display line at POS as STR with FACE.

FACE defaults to inheriting from default and highlight."
  (let ((ol (save-excursion
              (goto-char pos)
              (make-overlay (line-beginning-position)
                            (line-end-position)))))
    (overlay-put ol 'display str)
    (overlay-put ol 'face 'bold)
    ol))

(remove-hook 'post-self-insert-hook #'blink-paren-post-self-insert-function)

(show-paren-mode 1)
(setq show-paren-style 'paren
      show-paren-delay 0.03
      show-paren-highlight-openparen t
      show-paren-when-point-inside-paren nil
      show-paren-when-point-in-periphery t)
#+END_SRC
When I'm doing dedicated editing, it's sometimes nice to have more colours,
especially for Lisps such as Emacs Lisp. However, it's too distracting in org
mode source blocks, and it also slows down the point's movement, so I find it
best not to enable it globally.
#+BEGIN_SRC emacs-lisp
;; (use-package rainbow-delimiters
;;   :hook (emacs-lisp-mode . rainbow-delimiters-mode))
#+END_SRC
Finally, =rainbow-mode= highlights hex-color strings with their colour. Very handy
for choosing colours, especially when editing CSS files.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :defer 2
  :diminish
  :config (rainbow-mode 1))
#+END_SRC
Highlight =.service= files like they are configuration files.
#+BEGIN_SRC emacs-lisp
(use-package systemd
  :commands systemd-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.service\\'" . systemd-mode))
  (add-to-list 'auto-mode-alist '("\\.timer\\'" . systemd-mode)))
#+END_SRC
** Quality of Life
*** Garbage Collection
This package minimizes the interference of garbage collection with the user
experience. That means fewer annoyingly long pauses while you are using Emacs.
#+BEGIN_SRC emacs-lisp
(use-package gcmh
  :defer 2
  :diminish
  :config (gcmh-mode 1))
#+END_SRC
*** Better Defaults
All the things (perhaps they seem little) that just make sense to have.
**** From Yes/No to y/n
This makes things so much simpler. There's not any ambiguity to begin with. And
it's two less characters to type.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
**** Stop Cursor Going into Minibuffer Prompt
Sometimes when going back in the minibuffer by using backspace or the left arrow
key, the cursor will move right back into the prompt, and when you start to type
again, Emacs will display the annoying message that the minibuffer text is read
only. This prevents you from manually having to move the cursor out of the
prompt and then back, or pressing =C-g= and starting over.
#+BEGIN_SRC emacs-lisp
(customize-set-variable
 'minibuffer-prompt-properties
 (quote (read-only t cursor-intangible t face minibuffer-prompt)))
#+END_SRC
**** Keystroke Echo Timeout
This is one of those things that I didn't think would be useful until I tried
it. When you type a keybinding, the key sequence shows up in the echo area. But
the default timeout, one second, is a bit too long for me.
#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.5)
#+END_SRC
**** Split Vertically by Default
Gotta maximize that vertical screen space. Besides, I always have 80 character
limits on my lines. To be honest, I have no idea how it works, but it seems to
make Emacs prefer splitting vertically.
#+BEGIN_SRC emacs-lisp
(setq split-height-threshold nil
      split-width-threshold 0)
#+END_SRC
**** Transient Mark Mode
#+BEGIN_SRC emacs-lisp
(transient-mark-mode 1)
#+END_SRC
**** Electric Pairs Mode
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
(setq electric-pair-pairs
      '((?\( . ?\))
        (?\" . ?\")
        (?\{ . ?\})))
#+END_SRC
**** Uniquify
Make two buffers with the same file name distinguishable. This isn't strictly
necessary because I use =smart-mode-line=, but the default style puts brackets
around the non-unique buffer names, and I prefer a less confusing style.
#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward)
#+END_SRC
**** Beginning of Line
[[https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][This article]] argues that it's usually more useful for =C-a= to take you to the
beginning of the indentation of the line (that is, the logical/contextual
beginning of the line) as opposed to the literal beginning of the line. I tend
to agree. If you do want to go to the actual beginning of the line, then just
press =C-a= again. Also, this frees up =M-m=, bound to =back-to-indentation=.
#+BEGIN_SRC emacs-lisp
(defun smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
(global-set-key [remap org-beginning-of-line]  'smarter-move-beginning-of-line)
#+END_SRC
**** Faster Pop-to-mark
[[http://endlessparentheses.com/faster-pop-to-mark-command.html][Endless Parentheses]] shows us this modification to =pop-to-mark= (bound to =C-u
C-t=). Now we can pop the mark multiple times by pressing =C-t= again, rather than
having to type both keystrokes again.
#+BEGIN_SRC emacs-lisp
(defun modi/multi-pop-to-mark (orig-fun &rest args)
  "Call ORIG-FUN until the cursor moves.
Try the repeated popping up to 10 times."
  (let ((p (point)))
    (cl-loop repeat 10 do
             (when (= p (point))
               (apply orig-fun args)))))

(advice-add 'pop-to-mark-command :around #'modi/multi-pop-to-mark)
#+END_SRC
**** Integrate Clipboard and Kill Ring
If you copy something into your clipboard from, say, the browser, then you can
paste it into Emacs. That's all well and good. But if you kill something in
Emacs after copying something to the clipboard, what you had in the clipboard is
lost. That is, the clipboard cannot make use of the power that comes with the
multiple entries in the kill ring. Let's fix that by adding the system
clipboard's contents to the kill ring.
#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC
**** Create Necessary Directories
I find it annoying to answer the prompt to make a new directory when making a
file in a nonexistent directory. And so we advise =find-file= to transparently
create necessary directories (from this [[https://superuser.com/questions/131538/can-i-create-directories-that-dont-exist-while-creating-a-new-file-in-emacs][SE post]]).
#+BEGIN_SRC emacs-lisp
(defadvice find-file (before make-directory-maybe (filename &optional wildcards) activate)
  "Create parent directory if not exists while visiting file."
  (unless (file-exists-p filename)
    (let ((dir (file-name-directory filename)))
      (unless (file-exists-p dir)
        (make-directory dir)))))
#+END_SRC
**** Auto =chmod +x=
Make files that start with a =#!= shebang executable.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
*** Work with Protected Files
Authorize actions. The package =sudo-edit= is excellent for editing files owned by
root.
#+BEGIN_SRC emacs-lisp
(when gm/user
  (use-package pinentry
    :demand t
    :config (pinentry-start))

  (use-package epa-file
    :ensure nil
    :init (epa-file-enable)
    :config (setenv "GPG_AGENT_INFO" nil)
    :custom
    (epg-gpg-program "/usr/bin/gpg2")
    (epa-file-cache-passphrase-for-symmetric-encryption t)
    (epa-file-select-keys nil)
    (epa-pinentry-mode 'loopback))

  (use-package sudo-edit
    :commands sudo-edit
    :bind (("C-c C-x r" . sudo-edit))))
#+END_SRC
*** Backups
Keep backups in a dedicated spot and not in the current directory: this saves a
lot clutter.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name (concat gmacs-cache-dir "backups")))))
#+END_SRC
I have lots of disk space, and not so much patience when I lose an important
file. So I save lots.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1
      version-control t
      vc-make-backup-files t
      create-lockfiles nil)
#+END_SRC
**** Autosave
I want to move the autosaved stuff into the cache dir: let's keep everything
nice and neat.
#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms `((".*" ,(expand-file-name (concat gmacs-cache-dir "auto-save")) t))
      auto-save-list-file-name (expand-file-name (concat gmacs-cache-dir "auto-save/.saves~")))
#+END_SRC
However, Emacs prints a lot of messages to the echo area telling you that a file
has been autosaved. This is unnecessary, so I use [[http://pragmaticemacs.com/emacs/make-emacs-a-bit-quieter/][this hack]] from Pragmatic Emacs
to quiet down the autosave. Essentially, we replace the default autosave
function with our own silent version.
#+BEGIN_SRC emacs-lisp
(setq auto-save-timeout 99999)

(defvar bjm/auto-save-timer nil
  "Timer to run `bjm/auto-save-silent'")

(defvar bjm/auto-save-interval 15
  "How often in seconds of idle time to auto-save with
`bjm/auto-save-silent'")

(defun bjm/auto-save-silent ()
  "Auto-save all buffers silently"
  (interactive)
  (do-auto-save t))

(setq bjm/auto-save-timer
      (run-with-idle-timer 0 bjm/auto-save-interval 'bjm/auto-save-silent))
#+END_SRC
**** History
It's nice to have a history of commands and other things so that you can get
right to work when you open a new Emacs instance, you can get right to work.
Without this, =*table--cell-backward-kill-paragraph= is the default command,
because they are sorted alphabetically. If this has ever been the first command
you wanted to execute after opening Emacs, please let me know.
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :ensure nil
  :defer 2
  :config
  (defun recentf-save-list ()
    (let ((inhibit-message t))
      "Save the recent list.
Write data into the file specified by `recentf-save-file'."
      (interactive)
      (condition-case error
          (with-temp-buffer
            (erase-buffer)
            (set-buffer-file-coding-system recentf-save-file-coding-system)
            (insert (format-message recentf-save-file-header
                                    (current-time-string)))
            (recentf-dump-variable 'recentf-list recentf-max-saved-items)
            (recentf-dump-variable 'recentf-filter-changer-current)
            (insert "\n\n;; Local Variables:\n"
                    (format ";; coding: %s\n" recentf-save-file-coding-system)
                    ";; End:\n")
            (write-file (expand-file-name recentf-save-file))
            (when recentf-save-file-modes
              (set-file-modes recentf-save-file recentf-save-file-modes))
            nil)
        (error
         (warn "recentf mode: %s" (error-message-string error))))))
  (recentf-mode 1)
  (run-at-time nil (* 5 60) 'recentf-save-list)
  :custom
  (recentf-save-file (expand-file-name "recentf" gmacs-cache-dir))
  (recentf-max-saved-items 1000)
  (recentf-max-menu-items 1000)
  (recentf-exclude '("/elpa/"
                     "/cache/"
                     "/tmp/)")))
#+END_SRC
Make things quieter.
#+BEGIN_SRC emacs-lisp
(defun suppress-messages (func &rest args)
  "Suppress message output from FUNC."
  ;; Some packages are too noisy.
  ;; https://superuser.com/questions/669701/emacs-disable-some-minibuffer-messages
  (cl-flet ((silence (&rest args1) (ignore)))
    (advice-add 'message :around #'silence)
    (unwind-protect
        (apply func args)
      (advice-remove 'message #'silence))))

;; Suppress "Cleaning up the recentf...done (0 removed)"
(advice-add 'recentf-cleanup :around #'suppress-messages)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(setq-default savehist-file (expand-file-name "savehist" gmacs-cache-dir)
              save-place-file (expand-file-name "saveplaces" gmacs-cache-dir)
              transient-history-file (expand-file-name "transient-history.el" gmacs-cache-dir)
              bookmark-default-file (expand-file-name "bookmarks" gmacs-cache-dir))
#+END_SRC
Now we specify what to save.
#+BEGIN_SRC emacs-lisp
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
*** Reloading
As I tinkered with my Emacs configuration, it quickly became clear to me that
reloading Emacs is useful when testing something out. There are three fronts on
which reloading is useful.

When a file is changed on the disk, I want the content in my Emacs buffer to
reflect that. The only problem with this is that you could lose data if you're
not careful but I autosave almost too often, so this is not a concern for me.
And so I enable =auto-revert-mode= globally. Given this, I silence the messages
that a buffer has been reverted.
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
(setq auto-revert-verbose nil)
(diminish 'auto-revert-mode)
#+END_SRC
When this doesn't work, I still want to be able to quickly revert a buffer
manually.
#+BEGIN_SRC emacs-lisp
(defalias 'rb 'revert-buffer)
(defalias 'arm 'auto-revert-mode)
#+END_SRC
The type of file I most often revert is PDFs, because I want to check the output
of =.tex= files exported from Org Mode. And so I don't need to double check before
I revert.
#+BEGIN_SRC emacs-lisp
(setq revert-without-query '("\\.pdf"))
#+END_SRC
Sometimes, however, there are other cases in which we want to reload a buffer.
The change have been not in the file's contents, but in an Emacs setting, such
as the colours of the theme. Or the buffer might not have been representing a
file at all. In these cases, it's usually easiest to revert every open buffer.
This might be a problem for you if you're one of those people who keeps hundreds
of buffers open at a time, but I like to close my buffers liberally with the
knowledge that =recentf= will remember where I've been for me. I obtained the
following function from [[https://emacs.stackexchange.com/questions/24459/revert-all-open-buffers-and-ignore-errors][Emacs Stack Exchange]].
#+BEGIN_SRC emacs-lisp
(defun modi/revert-buffers (&optional buffers)
  "Refresh all open file buffers without confirmation. If BUFFERS is given, revert all elements of BUFFERS instead.
Buffers in modified (not yet saved) state in emacs will not be reverted. They
will be reverted though if they were modified outside emacs.
Buffers visiting files which do not exist any more or are no longer readable
will be killed."
  (interactive)
  (unless buffers (setq buffers (buffer-list)))
  (dolist (buf buffers)
    (let ((filename (buffer-file-name buf)))
      ;; Revert only buffers containing files, which are not modified;
      ;; do not try to revert non-file buffers like *Messages*.
      (when (and filename
                 (not (buffer-modified-p buf)))
        (if (file-readable-p filename)
            ;; If the file exists and is readable, revert the buffer.
            (with-current-buffer buf
              (revert-buffer t t))
          ;; Otherwise, kill the buffer.
          (let (kill-buffer-query-functions) ; No query done when killing buffer
            (kill-buffer buf)
            (message "Killed non-existing/unreadable file buffer: %s" filename))))))
  (message "Finished reverting buffers."))
#+END_SRC
Other times, we need to reload Emacs fully. To completely reload Emacs, we just
run the procedure of =init.el= again. Usually, we want to load the byte-compiled
version, but for those cases where we just want to load the uncompiled =.el= file,
a prefix argument does the job. I disable =after-save-hook= because I set up
asynchronous tangling and byte-compilation [[#tangle-async][here]].

Finally, I hope it doesn't come to this too often, but sometimes we must close
Emacs entirely and start a new session. I know, I can feel the agony. =C-x C-c=,
then move your mouse to click Emacs again! Luckily, there's a package for that.
This kills Emacs and starts a new session.
#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :commands restart-emacs)
#+END_SRC
Our function completely restarts, compiles and reloads with a prefix argument,
and just loads the existing =.el= file with two prefix arguments.
#+BEGIN_SRC emacs-lisp
(defun gm/reload (p)
  (interactive "P")
  (let ((after-save-hook nil)
        (org (expand-file-name "gmacs.org" user-emacs-directory))
        (el (expand-file-name "gmacs.el" user-emacs-directory))
        (elc (expand-file-name "gmacs.elc" user-emacs-directory))
        (init (expand-file-name "init.el" user-emacs-directory)))
    (cond ((equal p '(4))
           (when (or (not (file-exists-p elc))
                     (file-newer-than-file-p org elc))
             (org-babel-tangle-file org el)
             (byte-compile-file el))
           (load-file init)
           (run-hooks 'after-init-hook))
          ((equal p '(16))
           (org-babel-load-file org))
          (t (restart-emacs)))))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(bind-key "C-c r" 'gm/reload)
#+END_SRC
*** Abbreviations
Abbrevs are a pretty common and useful feature in editors. You can define
abbrevs, which are strings. When you type space after an abbrev, it is expanded
to whatever you want. Saves a lot of keystrokes.
#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name (expand-file-name "abbrevs.el" user-emacs-directory))
(setq-default abbrev-mode t)
(setq save-abbrevs 'silently)
(diminish 'abbrev-mode)
(bind-key "C-c M a" #'abbrev-mode)
#+END_SRC
*** Async Without Results Window
#+BEGIN_SRC emacs-lisp
(defun async-shell-command-no-window (command)
  (interactive)
  (let ((display-buffer-alist
        (list (cons "\\*Async Shell Command\\*.*"
          (cons #'display-buffer-no-window nil)))))
    (async-shell-command
     command)))
#+END_SRC
*** Insert Key Sequence
This command takes a key sequence and inserts it into the buffer. This is
surprisingly much easier than typing it in manually. I got it from [[http://endlessparentheses.com/inserting-the-kbd-tag-in-org-mode.html][this article]].
#+BEGIN_SRC emacs-lisp
(defun endless/insert-key (key)
  "Ask for a key then insert its description.
Will work on both org-mode and any mode that accepts plain html."
  (interactive "kType key sequence: ")
  (let* ((orgp (derived-mode-p 'org-mode))
         (tag (if orgp "=%s=" "<kbd>%s</kbd>")))
    (if (null (equal key "\C-m"))
        (insert
         (format tag (help-key-description key nil)))
      (insert (format tag ""))
      (forward-char (if orgp -1 -6)))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c k" . endless/insert-key)
#+END_SRC
*** Swap Windows
Every now and then, you'll want to switch the order of the buffers in Emacs.
This usually happens to me if I have something I'm reading in one buffer (code
reference, PDF) and something I'm writing in the other. I got this from
[[https://github.com/bbatsov/crux][bbatsov/crux]].
#+BEGIN_SRC emacs-lisp
(defun gm/swap-windows (arg)
  "Transpose the buffers shown in two windows.
Prefix ARG determines if the current windows buffer is swapped
with the next or previous window, and the number of
transpositions to execute in sequence."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
            (next-win (window-buffer (funcall selector))))
        (set-window-buffer (selected-window) next-win)
        (set-window-buffer (funcall selector) this-win)
        (select-window (funcall selector)))
      (setq arg (if (> arg 0) (1- arg) (1+ arg))))))

(bind-key "C-x 4 t" #'gm/swap-windows)
#+END_SRC
*** Tangle Config File
:PROPERTIES:
:CUSTOM_ID: tangle-async
:END:
I used to have my =init.el= set up so that, if =gmacs.elc= did not exist, it would
tangle =gmacs.org=. This unfortunately means that Emacs takes a long time to start
up (about 6 seconds). To solve this, I tangle this very file on save.

First, we set up a function to do the tangling. We have to, for example, refer
to =user-emacs-directory= and not =user-emacs-directoryectory=, and run =(require
'ob-tangle)= because the function is run in its own subprocess (this is what
allows it to be asynchronous).
#+BEGIN_SRC emacs-lisp
(defun gm/tangle-gmacs-helper ()
  (let ((src (expand-file-name "gmacs.org" user-emacs-directory))
        (dst (expand-file-name "gmacs.el" user-emacs-directory))
        (byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local)))
    (require 'ob-tangle)
    (org-babel-tangle-file src dst)
    (byte-compile-file dst)))
#+END_SRC
Then, we wrap this in an asynchronous process. If the config file is already
being tangled, we kill that process and start a new one. I only really want to
know about this process if it failed.
#+BEGIN_SRC emacs-lisp
(defvar gm--tangle-process nil)

(defun gm/tangle-gmacs ()
  (interactive)
  (let ((proc gm--tangle-process)
        (kill-buffer-query-functions nil))
    (when (process-live-p proc)
      (kill-process proc)
      (kill-buffer (process-buffer proc))))
  (let ((proc (async-start (symbol-function #'gm/tangle-gmacs-helper)
               (lambda (result)
                 (unless result
                   (message "GMACS unsuccessfully tangled: %s" result))))))
    (setq gm--tangle-process proc)))
#+END_SRC
Finally. we wrap this in a function that checks whether we're in the right file.
It would be inefficient to tangle the configuration file every time a different
file was edited and saved.
#+BEGIN_SRC emacs-lisp
(defun gm/tangle-if-config ()
    (when (string-suffix-p "gmacs.org" (buffer-file-name))
      (gm/tangle-gmacs)))

(add-hook 'after-save-hook #'gm/tangle-if-config)
#+END_SRC
*** Benchmarking
**** Functions
To optimize a function, you need to know the actual difference your changes
make.
#+BEGIN_SRC emacs-lisp
(autoload 'benchmark-elapse "benchmark")
#+END_SRC
**** Startup
If I introduce a new feature that increases my startup time, I can test things
out quantitatively with =esup=, a built-in feature.
#+BEGIN_SRC emacs-lisp
(use-package esup
  :commands esup)
#+END_SRC
*** UTF-8
From [[https://masteringemacs.org/article/working-coding-systems-unicode-emacs][Mastering Emacs]].
#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC
*** Faster Scroll Down
I found this snippet on [[https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag/28746][StackExchange]]. To summarize, =next-line= called
=line-move-partial=, which is expensive. The function =previous-line= does not do
this, so scrolling forward can sometimes feel jumpy, even when scrolling up is
smooth.
#+BEGIN_SRC emacs-lisp
(setq auto-window-vscroll nil)
#+END_SRC
*** Dump Vars to File
#+BEGIN_SRC emacs-lisp
(defun dump-vars-to-file (varlist filename &optional lines)
  "simplistic dumping of variables in VARLIST to a file FILENAME"
  (save-excursion
    (let ((buf (find-file-noselect filename)))
      (set-buffer buf)
      (erase-buffer)
      (dump varlist buf lines)
      (save-buffer))))

(defun dump (varlist buffer &optional lines)
  "insert into buffer the setq statement to recreate the variables in VARLIST"
  (let ((func (if lines 'pp 'print)))
  (cl-loop for var in varlist do
        (funcall func (list 'setq var (list 'quote (symbol-value var))) buffer))))
#+END_SRC
*** Add Package to Dotfiles
#+BEGIN_SRC emacs-lisp
(defun gm/package-linux-add (&optional package)
  (interactive)
  (let ((file "~/dotfiles/packages.txt")
        (package (if package package (read-string "Package name: "))))
  (with-temp-file file
    (insert (concat package "\n"))
    (insert-file-contents file)
    (sort-lines nil (point-min) (point-max))
  (buffer-string))))
#+END_SRC
*** Convert Hex to String
This comes in handy sometimes. I currently use it to decode information sent
from qutebrowser.
#+BEGIN_SRC emacs-lisp
(defun hex-to-string (s)
  (concat (--map (string-to-number (concat it) 16) (-partition 2 (string-to-list s)))))
#+END_SRC
*** Get Matches in Buffer
#+BEGIN_SRC emacs-lisp
(defun matches-in-buffer (regexp &optional buffer)
  "return a list of matches of REGEXP in BUFFER or the current buffer if not given."
  (let ((matches))
    (save-match-data
      (save-excursion
        (with-current-buffer (or buffer (current-buffer))
          (save-restriction
            (widen)
            (goto-char 1)
            (while (search-forward-regexp regexp nil t 1)
              (push (match-string-no-properties 0) matches)))))
      matches)))
#+END_SRC
*** Alias
Make commands easier.
#+BEGIN_SRC emacs-lisp
(defalias 'md 'mkdir)
(defalias 'mk 'mkdir)
#+END_SRC
*** Update Environment Variables
We can reload the environment variables without restarting Emacs by sending this
command to the client.
#+BEGIN_SRC emacs-lisp
(defun gm/update-env (fn)
  (let ((str
         (with-temp-buffer
           (insert-file-contents fn)
           (buffer-string)))
        lst)
    (setq lst (split-string str "\000"))
    (while lst
      (setq cur (car lst))
      (when (string-match "^\\(.*?\\)=\\(.*\\)" cur)
        (setq var (match-string 1 cur))
        (setq value (match-string 2 cur))
        (setenv var value))
      (setq lst (cdr lst)))))
#+END_SRC
*** Quit Current Context
Quit minibuffer more easily. No more hammering =C-g=.
#+BEGIN_SRC emacs-lisp
(defun keyboard-quit-context+ ()
  "Quit current context.

This function is a combination of `keyboard-quit' and
`keyboard-escape-quit' with some parts omitted and some custom
behavior added."
  (interactive)
  (cond ((region-active-p)
         ;; Avoid adding the region to the window selection.
         (setq saved-region-selection nil)
         (let (select-active-regions)
           (deactivate-mark)))
        ((eq last-command 'mode-exited) nil)
        (current-prefix-arg
         nil)
        (defining-kbd-macro
          (message
           (substitute-command-keys
            "Quit is ignored during macro defintion, use \\[kmacro-end-macro] if you want to stop macro definition"))
          (cancel-kbd-macro-events))
        ((active-minibuffer-window)
         (when (get-buffer-window "*Completions*")
           ;; hide completions first so point stays in active window when
           ;; outside the minibuffer
           (minibuffer-hide-completions))
         (abort-recursive-edit))
        (t
         (when completion-in-region-mode
           (completion-in-region-mode -1))
         (let ((debug-on-quit nil))
           (signal 'quit nil)))))

(global-set-key [remap keyboard-quit] #'keyboard-quit-context+)
#+END_SRC
** Wordsmithing
*** Basic Configuration
**** Sentences End With a Single Space
This is necessary to make sentence navigation commands work for me. I also don't
live in the typewriter days where the
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
**** Delete Selection
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC
**** Don't Adjust Point When Pasting by Mouse
Pasting into Emacs by middle-clicking can be nice, but I don't want the click to
change the location of the point and then paste there instead of where the point
originally was.
#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)
#+END_SRC
**** Ban Whitespace
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook #'delete-trailing-whitespace)
#+END_SRC
**** Autofill
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode 1)
(diminish 'visual-line-mode)
#+END_SRC
Nicely wrap lines for text mode.
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'auto-fill-mode)
(add-hook 'change-log-mode-hook 'turn-on-auto-fill)
(diminish 'auto-fill-function)
#+END_SRC
Default wrap at 80 characters.
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC
*** Utilities
**** Dictionary
See this [[http://jsomers.net/blog/dictionary][beautiful post]] by James Somers on why you should use this dictionary.
It's Webster's original, his magnum opus.
#+BEGIN_SRC emacs-lisp
(autoload #'sdcv-search "sdcv-mode")
(bind-key "C-c d" #'sdcv-search)
#+END_SRC
On Arch Linux, this goes with the =sdcv= package.
**** Writing
A minor mode that centres the text in the buffer. Nice distraction-free
environment for writing.
#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :commands olivetti-mode)
#+END_SRC
A major mode for writing screenplays in the =.fountain= format.
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package fountain-mode
  :commands fountain-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.fountain\\'" . fountain-mode))
  :config
  (add-hook 'fountain-mode-hook
            (lambda () (auto-fill-mode -1)
              (olivetti-mode 1)))
  <<fountain-mode>>
  :custom
  (fountain-export-font "Courier New")
  (fountain-export-scene-heading-format '(bold)))
#+END_SRC
The default export function has some annoying behaviour such as asking if you
want to overwrite the exported file and switching to the export buffer, so I
redefine the function here.
#+BEGIN_SRC emacs-lisp :noweb-ref fountain-mode
(defun fountain-export-buffer (format &optional snippet buffer)
  "Export current buffer or BUFFER to export format FORMAT.

If destination buffer is not empty, ask to overwrite or generate
a new buffer. If destination buffer is the same as source buffer,
generate a new buffer.

Switch to destination buffer if complete without errors,
otherwise kill destination buffer."
  ;; If called interactively, present export format options.
  (interactive
   (list (intern
          (completing-read "Export format: "
                           (mapcar #'car fountain-export-formats) nil t))
         (car current-prefix-arg)))
  (unless buffer
    (save-buffer)
    (setq buffer (current-buffer)))
  (let ((dest-buffer (get-buffer-create
                      (fountain-export-get-filename format buffer)))
        (hook (plist-get (cdr (assq format fountain-export-formats))
                         :hook))
        string complete)
    (unwind-protect
      ;; Export the region to STRING.
      (setq string
            (fountain-export-region (point-min) (point-max) format snippet))
      ;; Insert STRING into DEST-BUFFER.
      (with-current-buffer dest-buffer
        (with-silent-modifications
          (erase-buffer)
          (insert string))
        (write-file (buffer-name)))
      (run-hooks hook))))
#+END_SRC
**** Easier Regexp
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :commands (anzu-query-replace anzu-query-replace-regexp)
  :diminish "杏"
  :bind
  (([remap query-replace] . 'anzu-query-replace)
   ([remap query-replace-regexp] . 'anzu-query-replace-regexp))
  :config
  (unless (keymap-parent lisp-mode-shared-map)
    (set-keymap-parent lisp-mode-shared-map prog-mode-map))
  (bind-key [convert] #'anzu-query-replace-at-cursor-thing prog-mode-map))
#+END_SRC
*** Spelling
**** Setup
The article [[https://joelkuiper.eu/spellcheck_emacs][Spell checking in Emacs]] helped me out in setting up spellchecking in
my own Emacs configuration.

We automatically spellcheck text buffers using =flyspell=. The only mode I write
prose in is Org Mode.
#+BEGIN_SRC emacs-lisp :noweb no-export
(defvar gm/spelling nil)

(use-package flyspell
  :diminish
  :commands flyspell-mode
  :init
  (when gm/user (add-hook 'org-mode-hook #'flyspell-mode))
  (after! notmuch
    (add-hook 'notmuch-message-mode-hook #'flyspell-mode))
  (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
    (add-hook hook (lambda () (flyspell-mode -1))))
  <<flyspell-init>>
  :config
  <<flyspell-settings>>)
#+END_SRC
Set up spellchecking using =ispell= and the dictionary =hunspell=. We set the
locally used dictionary to Canadian English, and we set up the list of valid
dictionaries. I found the official Canadian English dictionary [[https://sourceforge.net/projects/wordlist/files/speller/2018.04.16/hunspell-en_CA-2018.04.16.zip/download?use_mirror=ayera][here]] (warning:
download link). The =.aff= and =.dic= files go in =/usr/share/hunspell/=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-init
(setq ispell-program-name "hunspell"
      ispell-local-dictionary "en_CA"
      ispell-hunspell-dictionary-alist
      '(("en_CA" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_CA") nil utf-8)))
#+END_SRC
As suggested by the Emacs wiki, I suppress messages, which slows down
performance when checking the entire buffer.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-init
(setq-default flyspell-issue-message-flag nil
              flyspell-issue-welcome-flag nil)
#+END_SRC
Spellchecking should not occur inside certain parts of Org Mode buffers like
property drawers and code source blocks. From [[http://endlessparentheses.com/ispell-and-org-mode.html?source=rss][Making Ispell work with org-mode in Emacs]].
#+BEGIN_SRC emacs-lisp
(defun endless/org-ispell ()
  "Configure `ispell-skip-region-alist' for `org-mode'."
  (make-local-variable 'ispell-skip-region-alist)
  (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
  (add-to-list 'ispell-skip-region-alist '("^#\+.*$"))
  (add-to-list 'ispell-skip-region-alist '("~" "~"))
  (add-to-list 'ispell-skip-region-alist '("=" "="))
  (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC" . "^#\\+END_SRC")))

(add-hook 'org-mode-hook #'endless/org-ispell)
#+END_SRC
**** Autocorrect and Abbreviations and Avy Selection
We want to be able to go to the previous error and correct it, then add it to
our global abbreviation list. As long as we spell the word incorrectly the same
way, we'll never make that typo again. I used to use code I took and modified
from [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Artur Malabarba]] and Howard Abrams, but now I just set this variable built
into =flyspell=.
#+BEGIN_SRC emacs-lisp :tanle no :noweb-ref flyspell-init
(setq flyspell-abbrev-p t)
#+END_SRC
However, I'm not a fan of the default interface for selecting spelling
corrections. Many forces in Emacs fight for window space, from expanded
minibuffers to popup windows. Both have their disadvantages. The minibuffer is
away from the action and requires you to look to a different place on the
screen. Popup windows can easily cause a jarring change in the way content is
displayed on the buffer. The solution is a [[https://github.com/alphapapa/frog-menu][frog menu]].

Its role is not fixed, but ad hoc; it pops up at the right moment in the right
place, just as the frog's tongue pouncing on the fly.

We use the =flyspell-correct= package to implement such an interface. It uses =avy=
for selection.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-settings
(autoload 'frog-menu-read "frog-menu")
(use-package flyspell-correct
  :commands flyspell-correct-wrapper
  :custom
  (flyspell-correct-interface #'frog-menu-flyspell-correct))
#+END_SRC
This code is from the =frog-menu= GitHub.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-init
(defun frog-menu-flyspell-correct (candidates word)
  "Run `frog-menu-read' for the given CANDIDATES.

List of CANDIDATES is given by flyspell for the WORD.

Return selected word to use as a replacement or a tuple
of (command . word) to be used by `flyspell-do-correct'."
  (let* ((corrects (if flyspell-sort-corrections
                       (sort candidates 'string<)
                     candidates))
         (actions `(("C-s" "Save word"         (save    . ,word))
                    ("C-a" "Accept (session)"  (session . ,word))
                    ("C-b" "Accept (buffer)"   (buffer  . ,word))
                    ("C-c" "Skip"              (skip    . ,word))))
         (prompt   (format "Correcting %s with [%s]"
                           word
                           (or ispell-local-dictionary
                               ispell-dictionary
                               "default")))
         (res      (frog-menu-read prompt corrects actions)))
    (unless res
      (error "Quit"))
    res))
#+END_SRC
[[http://pragmaticemacs.com/emacs/jump-back-to-previous-typo/][This article]] thinks that going to the previous error is more useful than going
to the next one. This is usually true, and aligns with the default behaviour
=flyspell-correct-wrapper=. The default binding on =C-;= is =flyspell='s built-in
autocorrect function. However, its suggestions are often not so useful, and
we've subsumed its role with =flyspell-correct= anyway.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-settings
(bind-key [remap flyspell-auto-correct-previous-word]
          #'flyspell-correct-wrapper flyspell-mode-map)
#+END_SRC
When moving backwards in the document, the correction menu can appear at the top
of the screen, obscuring the context surrounding the error.
#+BEGIN_SRC emacs-lisp
;; (advice-add 'flyspell-correct-wrapper :before #'recenter-top-bottom)
#+END_SRC
**** Correct Double Capitals
Taken from [[https://emacs.stackexchange.com/questions/13970/fixing-double-capitals-as-i-type/13975#13975][Stack Exchange]]. It's a piece of code with a great impact to
complexity ratio. Whenever you're a bit slow in releasing the Shift key and type
something like "This," =dubcaps-mode= converts it to "This" for you automatically.
This isn't really a hindrance, because if I actually want two capital letters in
a row, I almost never want a lowercase letter to follow.
#+BEGIN_SRC emacs-lisp
(defun gm/dcaps-to-scaps ()
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (let ((point (point)))
    (when (and (= ?w (char-syntax (char-before)))
               (save-excursion
                 (and (if (called-interactively-p 'interactive)
                          (skip-syntax-backward "w")
                        (= -3 (skip-syntax-backward "w")))
                      (let (case-fold-search)
                        (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
                      (gm/capitalize-word))))
      (goto-char point))))

(define-minor-mode gm/dubcaps-mode
  "Toggle `gm/dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  (if gm/dubcaps-mode
      (add-hook 'post-self-insert-hook #'gm/dcaps-to-scaps nil 'local)
    (remove-hook 'post-self-insert-hook #'gm/dcaps-to-scaps 'local)))

(add-hook 'text-mode-hook #'gm/dubcaps-mode)
#+END_SRC
**** Remove Words
Sometimes we accidentally add a word to our personal list and want to remove it.
#+BEGIN_SRC emacs-lisp
(defun gm/remove-personal-word ()
  (interactive)
  (let ((file (format "~/.hunspell_%s" ispell-local-dictionary))
        wordlist)
    (progn
      (find-file "~/.hunspell_en_CA")
      (setq wordlist (buffer-string))
      (kill-buffer))
    (let* ((words (nreverse (split-string wordlist "\n")))
           (word (ivy-read "Word to delete: " words))))
    (with-temp-file file
      (setq words (delete word words))
      (dolist (w words)
        (insert (format "%s\n" w))))))
#+END_SRC
*** Text Manipulation
**** Cut/Paste
From the infamous Xah Lee.
#+BEGIN_SRC emacs-lisp
(defun xah-cut-line-or-region ()
  "Cut current line, or text selection.
When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region').
URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2015-06-10"
  (interactive)
    (progn (if (use-region-p)
               (kill-region (region-beginning) (region-end) t)
             (kill-region (line-beginning-position) (line-beginning-position 2)))))

(defun xah-copy-line-or-region ()
  "Copy current line, or text selection.
When called repeatedly, append copy subsequent lines.
When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').

URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2018-09-10"
  (interactive)
  (if current-prefix-arg
      (progn
        (copy-region-as-kill (point-min) (point-max)))
    (if (use-region-p)
        (progn
          (copy-region-as-kill (region-beginning) (region-end)))
      (if (eq last-command this-command)
          (if (eobp)
              (progn )
            (progn
              (kill-append "\n" nil)
              (kill-append
               (buffer-substring-no-properties (line-beginning-position) (line-end-position))
               nil)
              (progn
                (end-of-line)
                (forward-char))))
        (if (eobp)
            (if (eq (char-before) 10 )
                (progn )
              (progn
                (copy-region-as-kill (line-beginning-position) (line-end-position))
                (end-of-line)))
          (progn
            (copy-region-as-kill (line-beginning-position) (line-end-position))
            (end-of-line)
            (forward-char)))))))

(bind-key "C-k" 'xah-cut-line-or-region)
(bind-key "M-w" 'xah-copy-line-or-region)
#+END_SRC
Org Mode rebinds =C-k= to its own kill line function, so we set up another binding
here.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(bind-key "C-k" #'xah-cut-line-or-region org-mode-map)
#+END_SRC
**** Paragraph Navigation
Keep blank lines as paragraph delimiters, no matter the major mode. From [[http://endlessparentheses.com/meta-binds-part-2-a-peeve-with-paragraphs.html][Meta
Binds Part 2: A peeve with paragraphs]].
#+BEGIN_SRC emacs-lisp
(bind-key "M-p" 'endless/backward-paragraph)
(bind-key "M-n" 'endless/forward-paragraph)

(defun endless/forward-paragraph (&optional n)
  "Advance just past next blank line."
  (interactive "p")
  (let ((para-commands
         '(endless/forward-paragraph endless/backward-paragraph)))
    ;; Only push mark if it's not active and we're not repeating.
    (or (use-region-p)
        (not (member this-command para-commands))
        (member last-command para-commands)
        (push-mark))
    ;; The actual movement.
    (dotimes (_ (abs n))
      (if (> n 0)
          (skip-chars-forward "\n[:blank:]")
        (skip-chars-backward "\n[:blank:]"))
      (if (search-forward-regexp
           "\n[[:blank:]]*\n[[:blank:]]*" nil t (cl-signum n))
          (goto-char (match-end 0))
        (goto-char (if (> n 0) (point-max) (point-min)))))))

(defun endless/backward-paragraph (&optional n)
  "Go back up to previous blank line."
  (interactive "p")
  (endless/forward-paragraph (- n)))
#+END_SRC
But Org Mode messes this up. So we setup a binding using the =:bind= keyword from
=use-package=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("M-n" . forward-paragraph)
("M-p" . backward-paragraph)
#+END_SRC
**** Transpose Elements
Add aliases to do this easily.
#+BEGIN_SRC emacs-lisp
(defalias 'ts 'transpose-sentences)
(defalias 'tp 'transpose-paragraphs)
(bind-key "C-r" 'transpose-chars)
#+END_SRC
**** Capitalize Word
The default behaviour, that pressing =M-c= here (with the cursor at =|=) =capit|alize=
produces =capitAlize= is silly; I can't think of a situation where I would want to
capitalize just the following character if the cursor is in the middle of a
word.
#+BEGIN_SRC emacs-lisp
(defun gm/capitalize-word ()
  (interactive)
  (let ((eol (eolp)))
    (when (and (eq (char-before) ? )
               (or (eq (char-after) ? )
                   (eolp)))
      (backward-char))
    (let* ((bounds (bounds-of-thing-at-point 'symbol))
           (beg (car bounds))
           (end (cdr bounds))
           (word (buffer-substring-no-properties beg end)))
      (delete-region beg end)
      (if (string= word (capitalize word))
          (insert (downcase word))
        (insert (capitalize word))))
    (if eol
        (forward-char)
      (forward-word)
      (backward-word))))

(bind-key "M-c" #'gm/capitalize-word)
#+END_SRC
**** Expand Region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :commands er/expand-region
  :bind (("C-=" . er/expand-region)
         ("M-2" . er/expand-region)))
#+END_SRC
**** Change Region to Title Case
#+BEGIN_SRC emacs-lisp
(defvar gm/title-case-skip-chars
  "^\"<>(){}[]“”‘’‹›«»「」『』【】〖〗《》〈〉〔〕")

(defun xah-title-case-region-or-line (@begin @end)
  "Title case text between nearest brackets, or current line, or text selection.
Capitalize first letter of each word, except words like {to, of,
the, a, in, or, and, …}. If a word already contains cap letters
such as HTTP, URL, they are left as is.

When called in a elisp program, *begin *end are region boundaries.
URL `http://ergoemacs.org/emacs/elisp_title_case_text.html'
Version 2017-01-11"
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (let (p1
           p2
           (skipChars gm/title-case-skip-chars))
       (progn
         (skip-chars-backward skipChars (line-beginning-position))
         (setq p1 (point))
         (skip-chars-forward skipChars (line-end-position))
         (setq p2 (point)))
       (list p1 p2))))
  (let* ((strPairs [[" A " " a "]
                    [" And " " and "]
                    [" At " " at "]
                    [" As " " as "]
                    [" By " " by "]
                    [" Be " " be "]
                    [" Into " " into "]
                    [" In " " in "]
                    [" Is " " is "]
                    [" It " " it "]
                    [" For " " for "]
                    [" Of " " of "]
                    [" Or " " or "]
                    [" On " " on "]
                    [" Via " " via "]
                    [" The " " the "]
                    [" That " " that "]
                    [" To " " to "]
                    [" Vs " " vs "]
                    [" With " " with "]
                    [" From " " from "]
                    ["'S " "'s "]
                    ["'T " "'t "]]))
    (save-excursion
      (save-restriction
        (narrow-to-region @begin @end)
        (downcase-region @begin @end)
        (upcase-initials-region (point-min) (point-max))
        (let ((case-fold-search nil))
          (mapc
           (lambda (x)
             (goto-char (point-min))
             (while
                 (search-forward (aref x 0) nil t)
               (replace-match (aref x 1) "FIXEDCASE" "LITERAL")))
           strPairs))))))
#+END_SRC
Note that one of the characters we skip is ="=.
**** Replace String
#+BEGIN_SRC emacs-lisp
(defalias 'rs 'replace-string)
#+END_SRC
** Programming
The age old debate: tabs or spaces? I say spaces.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 2)
#+END_SRC
Make =TAB= indent first then perform completion, if any.
#+BEGIN_SRC emacs-lisp
(setq-default tab-always-indent 'complete)
#+END_SRC
Set up =flycheck=.
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package flycheck
  :commands flycheck-mode
  :diminish (flycheck-mode " Ψ")
  :custom (flycheck-display-errors-delay .3)
  :hook (prog-mode . flycheck-mode))
#+END_SRC
Relative line numbers, useful for Vim-like navigation with God Mode.
#+BEGIN_SRC emacs-lisp
(use-package nlinum-relative
  :hook (prog-mode . nlinum-relative-mode))
#+END_SRC
Emacs treats camelCase strings as a single word by default. Not anymore.
#+BEGIN_SRC emacs-lisp
(global-subword-mode 1)
#+END_SRC
We use =lsp-mode= to set up an IDE.
#+BEGIN_SRC emacs-lisp
(use-package company
  :custom
  (company-minimum-prefix-length 1)
  (company-idle-delay 0.0))

(use-package lsp-mode
  ;; set prefix for lsp-command-keymap (few alternatives - "C-l", "C-c l")
  :init (setq lsp-keymap-prefix "s-l")
  :hook ((c++-mode . lsp))
  :commands lsp
  :config
  (use-package lsp-ivy :commands lsp-ivy-workspace-symbol)
  (use-package company-lsp :commands company-lsp))
#+END_SRC
*** Flycheck Hydra
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-flycheck (:color blue)
  "
  ^
  ^Flycheck^          ^Errors^            ^Checker^
  ^────────^──────────^──────^────────────^───────^─────
  _q_ quit            _<_ previous        _?_ describe
  _M_ manual          _>_ next            _d_ disable
  _v_ verify setup    _f_ check           _m_ mode
  ^^                  _l_ list            _s_ select
  ^^                  ^^                  ^^
  "
  ("q" nil)
  ("<" flycheck-previous-error :color pink)
  (">" flycheck-next-error :color pink)
  ("?" flycheck-describe-checker)
  ("M" flycheck-manual)
  ("d" flycheck-disable-checker)
  ("f" flycheck-buffer)
  ("l" flycheck-list-errors)
  ("m" flycheck-mode)
  ("s" flycheck-select-checker)
  ("v" flycheck-verify-setup))

(bind-key "C-c f" #'hydra-flycheck/body)
#+END_SRC
suppress
*** Python
Indent with 4 spaces.
#+BEGIN_SRC emacs-lisp
(setq-default python-indent-offset 4)
#+END_SRC
Turn Emacs into basically a Python IDE.
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :config
  (use-package py-autopep8
    :hook (elpy-mode . py-autopep8-enable-on-save))
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  :hook
  (python-mode . elpy-enable)
  (python-mode . elpy-mode)
  (elpy-mode . flycheck-mode))
#+END_SRC
*** Lisp
Because =use-package= is never actually evaluated/loaded if we byte-compile
=gmacs.el=, it is not automatically syntax-highlighted as a macro.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'emacs-lisp-mode
  '(("use-package " . font-lock-keyword-face)))
#+END_SRC
We don't want annoying comments about having, for example, =;;; package ---
summary= at the top of an Emacs Lisp file.
#+BEGIN_SRC emacs-lisp
(setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
#+END_SRC
Sexps are everything in Lisp. The default bindings to traverse them forwards and
backwards are clunky: =C-M-f=, =C-M-b=. Since I've already taken my =M-digit=
[[*Window Management][bindings]], I'm willing to do it again.
#+BEGIN_SRC emacs-lisp
(bind-key "M-9" #'backward-sexp)
(bind-key "M-0" #'forward-sexp)
#+END_SRC
*** C++
#+BEGIN_SRC emacs-lisp
(setq-default c-default-style "linux"
              c-basic-offset 4)
#+END_SRC
** Packages
*** Package Management
**** Initialize During Emacs
Fix loading the GNU archive.
#+BEGIN_SRC emacs-lisp
(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+END_SRC
Although we load and initialize all packages at startup, it is sometimes useful
for the user to be able to interact with this process after it has taken place.
For example, packages must be initialized to evaluate code blocks with
=use-package= declarations in them.
#+BEGIN_SRC emacs-lisp :noweb no-export
(defun gm/package-intiialize ()
  (interactive)
  <<pack-arch>>
  (require 'use-package)
  (package-initialize)
  (package-refresh-contents))
#+END_SRC
**** Helpful
This package is a more informative alternative to the default Emacs
documentation/help feature. The [[https://github.com/Wilfred/helpful][author's pictures]] explain it better than I
could.
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :bind
  (("C-h f" . helpful-callable)
   ("C-h v" . helpful-variable)
   ("C-h k" . helpful-key)
   ("C-h F" . helpful-function)       ; no macros
   ("C-h C" . helpful-command)        ; only interactive functions
  )
  :commands (helpful-callable
             helpful-variable
             helpful-key
             helpful-function
             helpful-command))
#+END_SRC
**** Paradox
#+BEGIN_SRC emacs-lisp
(use-package paradox
  :commands (package-initialize)
  :config (paradox-enable))
#+END_SRC
*** Special Modes
**** PDF Tools
Basic configuration.
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :mode (("\\.pdf\\'" . pdf-view-mode))
  :commands pdf-view-mode
  :init
  (defun gm-pdf-open-external (&optional filename)
    (require 'dired-open)
    (interactive)
    (let (close)
    (unless filename
      (setq filename (file-truename buffer-file-name))
      (setq close t))
    (dired-open--start-process filename "xdg-open")
    (when close
      (kill-buffer-and-window))))
  :config
  (setq pdf-annot-activate-created-annotations t)
  (after! counsel
    (bind-key "C-s" #'counsel-grep-or-swiper pdf-view-mode-map))
  (bind-key "O" #'gm-pdf-open-external pdf-view-mode-map)
  (bind-key "O" #'gm-pdf-open-external doc-view-mode-map)
  :diminish pdf-view-midnight-minor-mode
  :bind (:map pdf-view-mode-map
              ("h" . pdf-annot-add-highlight-markup-annotation)
              ("t" . pdf-annot-add-text-annotation)
              ("D". pdf-annot-delete)
              ("r" . pdf-view--rotate)
              ("n" . pdf-view-next-line-or-next-page)
              ("C-n" . pdf-view-next-page-command)
              ("p" . pdf-view-previous-line-or-previous-page)
              ("C-p" . pdf-view-previous-page-command))
  :hook
  (pdf-view-mode . pdf-view-midnight-minor-mode)
  (pdf-view-mode . pdf-view-fit-width-to-window))
#+END_SRC
Open with external viewer by default if wanted.
#+BEGIN_SRC emacs-lisp
(require 'openwith)
(setq openwith-associations '(("\\.pdf\\'" "zathura" (file))
                              ("\\.djvu\\'" "zathura" (file))))
#+END_SRC
Allow rotation.
#+BEGIN_SRC emacs-lisp
(after! pdf-tools
  (defun pdf-view--rotate (&optional counterclockwise-p page-p)
  "Rotate PDF 90 degrees.  Requires pdftk to work.\n
Clockwise rotation is the default; set COUNTERCLOCKWISE-P to
non-nil for the other direction.  Rotate the whole document by
default; set PAGE-P to non-nil to rotate only the current page.
\nWARNING: overwrites the original file, so be careful!"
  (interactive)
  ;; error out when pdftk is not installed
  (if (null (executable-find "pdftk"))
      (error "Rotation requires pdftk")
    ;; only rotate in pdf-view-mode
    (when (eq major-mode 'pdf-view-mode)
      (let* ((rotate (if counterclockwise-p "left" "right"))
             (file   (format "\"%s\"" (pdf-view-buffer-file-name)))
             (page   (pdf-view-current-page))
             (pages  (cond ((not page-p)                        ; whole doc?
                            (format "1-end%s" rotate))
                           ((= page 1)                          ; first page?
                            (format "%d%s %d-end"
                                    page rotate (1+ page)))
                           ((= page (pdf-info-number-of-pages)) ; last page?
                            (format "1-%d %d%s"
                                    (1- page) page rotate))
                           (t                                   ; interior page?
                            (format "1-%d %d%s %d-end"
                                    (1- page) page rotate (1+ page))))))
        ;; empty string if it worked
        (if (string= "" (shell-command-to-string
                         (format (concat "pdftk %s cat %s "
                                         "output %s.NEW "
                                         "&& mv %s.NEW %s")
                                 file pages file file file)))
            (pdf-view-revert-buffer nil t)
          (error "Rotation error!")))))))
#+END_SRC
Open PDFs to where they were last opened.
#+BEGIN_SRC emacs-lisp
(use-package pdf-view-restore
  :after pdf-tools
  :config
  (add-hook 'pdf-view-mode-hook #'pdf-view-restore-mode)
  :custom
  (pdf-view-restore-filename "~/.emacs.d/cache/.pdf-view-restore"))
#+END_SRC
**** Epub reading
We use =nov.el=. Change default reading font from Source Sans Pro (my default
variable pitch font) to Minion Pro.
#+BEGIN_SRC emacs-lisp
(defun gm/nov-font-setup ()
  (face-remap-add-relative 'variable-pitch :family "Minion Pro"
                                           :height 2.0))
#+END_SRC
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package nov
  :commands (nov-mode)
  :init (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  :hook (nov-mode . gm/nov-font-setup)
  :config
  <<nov-settings>>)
#+END_SRC
Justifying e-book text. This code was taken from [[https://github.com/wasamasa/nov.el][wasamasa/nov.el]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref nov-settings
(require 'justify-kp)
(setq nov-text-width most-positive-fixnum)

(defun my-nov-window-configuration-change-hook ()
  (my-nov-post-html-render-hook)
  (remove-hook 'window-configuration-change-hook
               'my-nov-window-configuration-change-hook
               t))

(defun my-nov-post-html-render-hook ()
  (if (get-buffer-window)
      (let ((max-width (pj-line-width))
            buffer-read-only)
        (save-excursion
          (goto-char (point-min))
          (while (not (eobp))
            (when (not (looking-at "^[[:space:]]*$"))
              (goto-char (line-end-position))
              (when (> (shr-pixel-column) max-width)
                (goto-char (line-beginning-position))
                (pj-justify)))
            (forward-line 1))))
    (add-hook 'window-configuration-change-hook
              'my-nov-window-configuration-change-hook
              nil t)))

(add-hook 'nov-post-html-render-hook 'my-nov-post-html-render-hook)
#+END_SRC
**** TeX
#+BEGIN_SRC emacs-lisp
(use-package tex
  :ensure auctex)
#+END_SRC
**** Webmode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode ("\\.scss\\'" . web-mode)
  :custom
  (web-mode-markup-indent-offset 2)
  (web-mode-css-indent-offset 2)
  (web-mode-code-indent-offset 2))
#+END_SRC
*** Eshell
I have started to use =eshell= as my primary shell. This command ensures that
=eshell= is opened next to, not instead of, my current buffer.
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package eshell
  :ensure nil
  :commands eshell
  :init
  <<eshell-init>>
  :config
  <<eshell>>)
#+END_SRC
Use =counsel= to load history.
#+BEGIN_SRC emacs-lisp
(after! counsel
  (bind-key [remap eshell-previous-matching-input] #'counsel-esh-history))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eshell-init
(defun eshell-other-frame (arg)
  "Open `eshell' in a new frame."
  (interactive "P")
  (let ((buf
         (let ((current-prefix-arg arg))
           (call-interactively 'eshell))))
    (switch-to-buffer (other-buffer buf))
    (switch-to-buffer-other-frame buf)))
#+END_SRC
I rebind the redundant help binding (there is already a more convenient prefix
map at =C-h=).
#+BEGIN_SRC emacs-lisp
(bind-key "<f1>" #'eshell-other-frame)
#+END_SRC
We also make some aliases.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eshell
(defun eshell/ff (&rest args)
  (apply #'find-file args))

(defun eshell/d (&rest args)
  (apply #'dired args))
#+END_SRC
My current workflow is to spawn =eshell= in a new frame, so I "advise" =exit= to
also kill the frame. However, I also don't want errors when there is only one
frame.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eshell
(defun eshell/exit ()
  (condition-case nil
      (let ((buf (current-buffer)))
        (with-current-buffer (get-buffer-create "*eshell messages*")
          (if (= 1 (length (frame-list)))
              (bury-buffer)
            (kill-buffer buf)
            (delete-frame))))
    (error nil)))
#+END_SRC
For command-line aliases, we don't need to read and write the file each time,
because we're not defining anything new, so we can write manually.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eshell
(after! em-alias
  (dolist
      (alias
       '(("x" "exit")
         ("l" "ls -1A $*")
         ("la" "ls -lAh $*")
         ("ll" "ls -lh $*")
         ("cpv" "cp -iv $*")
         ("mvv" "mv -iv $*")
         ("rmv" "rm -v $*")
         ("md" "eshell/mkdir -p $*")
         ("mdc" "eshell/mkdir -p $* ; cd $1")))
    (add-to-list 'eshell-command-aliases-list alias))
(eshell-write-aliases-list))
#+END_SRC
Use TRAMP to use Eshell as root.
#+BEGIN_SRC emacs-lisp
(require 'em-tramp)
(setq password-cache t)
(setq password-cache-expiry 3600)
#+END_SRC
Don't load the banner, and load TRAMP.
#+BEGIN_SRC emacs-lisp
(after! esh-module
  (delq 'eshell-banner eshell-modules-list)
  (push 'eshell-tramp eshell-modules-list))
#+END_SRC
Increase default history size.
#+BEGIN_SRC emacs-lisp
(setq eshell-history-size 1024)
#+END_SRC
*** Dired
Great for renaming files in bulk.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package dired
  :ensure nil
  :commands dired
  :config
  <<dired-settings>>)
#+END_SRC
Easily sort based on a lot of options such as name, time, size, and
extension. Use ~S~ to use in a Dired buffer.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(use-package dired-quick-sort
  :config (dired-quick-sort-setup))
#+END_SRC
I don't have much of a use for just listing the contents of a directory, and I
sometimes accidentally use this command instead of =dired=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(bind-key "C-x C-d" #'dired)
#+END_SRC
Have the most up-to-date version of the buffer when using Dired.
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC
Don't show details by default.
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook #'dired-hide-details-mode)
#+END_SRC
Allow the user to copy the full file path.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(defun gm/dired-copy-path-at-point ()
    (interactive)
    (dired-copy-filename-as-kill 0))

(bind-key "W" #'gm/dired-copy-path-at-point dired-mode-map)
#+END_SRC
Show recursive folder sizes.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(use-package dired-du
  :commands dired-du-mode
  :hook (dired-du-mode . (lambda! () (dired-du--toggle-human-readable)
                                  (dired-du--toggle-human-readable)))
  :bind (:map dired-mode-map
              ("C-x M-r" . dired-du-mode)))
#+END_SRC
For more involved needs, there is also a dedicated package for analyzing disk
usage.
#+BEGIN_SRC emacs-lisp
(use-package disk-usage
  :commands (disk-usage))
#+END_SRC
Allow Dired to recursively copy and delete directories. The option ~always~
ensures that no confirmation dialog comes up; ~top~ would do it only one layer
deep.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(setq dired-recursive-copies 'always)
(setq dired-recursive-deletes 'always)
#+END_SRC
But I don't want to permanently delete things. Not yet, anyway.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(setq delete-by-moving-to-trash t)
#+END_SRC
Even then, I sometimes want to actually delete files.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(after! dired
  (defun gm/really-delete ()
    (interactive)
    (let ((delete-by-moving-to-trash nil))
      (dired-do-delete))
    (revert-buffer)))
(bind-key "F" #'gm/really-delete dired-mode-map)
(add-hook 'dired-mode-hook (lambda () (bind-key "F" #'gm/really-delete dired-mode-map)))
#+END_SRC
We might as well perform file operations asynchronously.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(autoload 'dired-async-mode "dired-async" nil t)
(add-hook 'dired-mode-hook 'dired-async-mode)
#+END_SRC
When you open, say, an audio or video file from Dired, Emacs displays the raw
data in that file in a text buffer. We want to open files with the appropriate
application.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(autoload 'dired-open-xdg "dired-open")
(bind-key "O" #'dired-open-xdg dired-mode-map)
#+END_SRC
Condense unique subtrees like GitHub does.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(use-package dired-collapse
  :ensure nil
  :hook (dired-mode . dired-collapse-mode))
#+END_SRC
Always follow symlinks to their source if the source is version
controlled.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(setq vc-follow-symlinks t)
#+END_SRC
For really big files, =rsync= is nice.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(defun gm/dired-rsync (dest)
  (interactive
   (list
    (expand-file-name
     (read-file-name
      "Rsync to: "
      (dired-dwim-target-directory)))))
  ;; store all selected files into "files" list
  (let ((files (dired-get-marked-files
                nil current-prefix-arg))
        ;; the rsync command
        (tmtxt/rsync-command
         "rsync -arvz --progress "))
    ;; add all selected file names as arguments
    ;; to the rsync command
    (dolist (file files)
      (setq tmtxt/rsync-command
            (concat tmtxt/rsync-command
                    (shell-quote-argument file)
                    " ")))
    ;; append the destination
    (setq tmtxt/rsync-command
          (concat tmtxt/rsync-command
                  (shell-quote-argument dest)))
    ;; run the async shell command
    (async-shell-command tmtxt/rsync-command "*rsync*")
    ;; finally, switch to that window
    (other-window 1)))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(bind-key "C" #'gm/dired-rsync dired-mode-map)
#+END_SRC
I often find the commands in Dired hard to remember.
#+BEGIN_SRC emacs-lisp :noweb-ref hydra
(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_z_ compress file  ^ ^              ^ ^                ^ ^                _?_ summary
_Z_ compress       _A_ find regexp  _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" gm/dired-rsync)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(bind-key "." 'hydra-dired/body dired-mode-map)
#+END_SRC
*** Magit
Magit, the magical Git client, is an amazing porcelain for Git inside of Emacs.
Seriously, I've forgotten how tedious using Git on the command line is, and
every time I have to is a pain. Emacs is worth using for this package alone. We
only load it from the entry points given in =:commands=. We also define a
quick-bind to quit the current Magit session and return to the previous window
configuration. This way, we can let Magit take up the full real estate on the
screen, and once we're done, we can get right back to where we left off.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (magit-status magit-blame magit-log-buffer-file magit-log-all)
  :init
  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))
  :config
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))
  (add-hook 'magit-process-find-password-functions 'magit-process-password-auth-source)
  :bind (("C-x g" . magit-status)
         :map magit-status-mode-map
              ("q" . magit-quit-session)))

(use-package ssh-agency
  :after magit)
#+END_SRC
*** Tramp
Make sure to keep backups locally and not remotely.
#+BEGIN_SRC emacs-lisp
(setq tramp-backup-directory-alist backup-directory-alist)
#+END_SRC
Set tramp connection history location.
#+BEGIN_SRC emacs-lisp
(after! tramp-cache
  (setq tramp-persistency-file (expand-file-name "tramp" gmacs-cache-dir)))
#+END_SRC
*** Ivy
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package ivy
  :diminish
  :demand t
  :config
  (ivy-mode 1)
  <<ivy>>
  :custom
  (ivy-re-builders-alist
   '((swiper . ivy--regex-plus)
     (ivy-switch-buffer . ivy--regex-plus)
     (t . ivy--regex-fuzzy)))
  (ivy-use-virtual-buffers t)
  (ivy-display-style 'fancy)
  (ivy-initial-inputs-alist nil))

(use-package flx
  :after ivy)

(use-package swiper
  :after ivy
  :commands (swiper swiper-all))

(use-package counsel
  :after ivy
  :bind
  ([remap execute-extended-command] . counsel-M-x)
  ([remap org-goto] . counsel-org-goto)
  ([remap find-file] . counsel-find-file)
  ("C-s" . counsel-grep-or-swiper)
  (:map ivy-minibuffer-map
        ([remap hungry-delete-backward] . nil))
  :custom
  (counsel-grep-base-command
   "rg -i -M 120 --color auto --line-number %s %s"))

(use-package amx
  :after counsel
  :config
  (amx-mode 1)
  :custom
  (amx-save-file (expand-file-name "amx" gmacs-cache-dir))
  (amx-history-length 50)
  (amx-show-key-bindings nil))
#+END_SRC
I want to ignore certain file extensions when searching for a file, so I add
them to the regexp in =counsel-find-file-ignore-regexp=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref ivy
(defconst gm/find-file-ignore-extensions
  '("aux" "bbl" "blg" "exe" "log" "meta" "out" "fls" "tdo" "toc" "xdv" "fdx" "bcf" "run.xml"
    "synctex.gz" "fdb_latexmk"
    "elc"
    "pyc"))

(defconst gm/find-file-ignore-dirs
  '("cache/" "auto/" "ltximg/"
    ".git/"
    "VideoDecodeStats/"))

(setq counsel-find-file-ignore-regexp
      (s-join "\\|" (list (concat (regexp-opt
                                   (--map (concat "." it) gm/find-file-ignore-extensions))
                                  "\\'")            ; make sure we only match end of filename
                          (regexp-opt
                           gm/find-file-ignore-dirs))))
#+END_SRC
We do something similar for =ivy-switch-buffer=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref ivy
(defconst gm/find-file-ignore-names
  '("*elfeed-org*"
    ".org-gcal-token"))

(add-to-list 'ivy-ignore-buffers (regexp-opt gm/find-file-ignore-names))
#+END_SRC
[[http://pragmaticemacs.com/page/6/][This post]] explains the pitfalls of the default behaviour of =ivy-yank-word= and
how to fix them. Now we can easily search for the word at point using =swiper=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref ivy
;; version of ivy-yank-word to yank from start of word
(defun bjm/ivy-yank-whole-word ()
  "Pull next word from buffer into search string."
  (interactive)
  (let (amend)
    (with-ivy-window
      ;;move to last word boundary
      (re-search-backward "\\b")
      (let ((pt (point))
            (le (line-end-position)))
        (forward-word 1)
        (if (> (point) le)
            (goto-char pt)
          (setq amend (buffer-substring-no-properties pt (point))))))
    (when amend
      (insert (replace-regexp-in-string "  +" " " amend)))))

(bind-key "M-w" #'bjm/ivy-yank-whole-word ivy-minibuffer-map)
#+END_SRC
*** God Mode
In =god-mode=, all keypresses are interpreted as if preceded by =C-= (as in
"Control"). For example, the sequence =2 n x s= goes down two lines then saves the
buffer.
#+BEGIN_SRC emacs-lisp
(use-package god-mode
  :commands (god-local-mode god-mode-all))
#+END_SRC
Easily enter God Mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref keychord
(key-chord-define-global "jk" 'god-mode-all)
#+END_SRC
Indicate whether we're in God mode with the cursor colour. I've seen other
people do this by having a bar cursor in "insert mode" (to borrow some
terminology from Vim) and a block cursor in "command mode" (in our case, God
Mode).
#+BEGIN_SRC emacs-lisp
(defun gm/god-mode-indicator ()
  (cond (god-local-mode
         (set-cursor-color "#dc322f"))
        (t (set-cursor-color "#657b83"))))

(add-hook 'god-mode-enabled-hook #'gm/god-mode-indicator)
(add-hook 'god-mode-disabled-hook #'gm/god-mode-indicator)
#+END_SRC
*** Hydra
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package hydra
  :defer 2
  :config
  <<hydra>>)
#+END_SRC
*** Which Key Mode
Helpful when you want to see completion for a certain sequence of prefix keys.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer 10
  :diminish
  :config (which-key-mode))
#+END_SRC
*** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :bind (("M-g" . avy-goto-word-1)))
#+END_SRC
Similarly, we use =ace-link= to open links quickly.
#+BEGIN_SRC emacs-lisp
(use-package ace-link
  :commands (ace-link-addr)
  :config (ace-link-setup-default)
  (after! org
    (bind-key "M-O" #'ace-link-org org-mode-map)))
#+END_SRC
We set up some easier to read faces.
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(avy-lead-face ((t (:inherit isearch-fail))))
 '(avy-lead-face-0 ((t (:inherit org-todo :background "#002b36")))))
#+END_SRC
*** Window Management
I don't like the default Emacs functionality of splitting windows but not
switching to the new window. I find myself pressing =M-3 C-x 0= pretty much every
time I split the window.
#+BEGIN_SRC emacs-lisp
(defun gm/split-window-below-and-switch ()
  (interactive)
  (split-window-below)
  (other-window 1))

(defun gm/split-window-right-and-switch ()
  (interactive)
  (split-window-right)
  (other-window 1))
#+END_SRC
To manage my windows. I use =ace-window=. The nice thing about this is that when
you use the equivalent of =other-window=, you don't have to remember which window
the "other one" is. Instead, you select the window with a number.
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :commands (ace-window
             delete-window
             delete-other-windows
             gm/split-window-right-and-switch
             gm/split-window-below-and-switch)
  :bind (("C-x o" . ace-window)
         ("M-o" . ace-window)
         ("C-x 0" . delete-window)
         ("M-1" . delete-other-windows)
         ("M-3" . gm/split-window-right-and-switch)
         ("M-4" . gm/split-window-below-and-switch)))
#+END_SRC
*** Projectile
A neat package to perform operations with respect to the active "project,"
usually a git repo. The most useful function for me is =projectile-find-file=.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :defer 5
  :diminish projectile-mode
  :config
  (use-package counsel-projectile :demand t)
  (projectile-mode)
  (projectile-load-known-projects))
#+END_SRC
I use a hydra to manage its many keybindings.
#+BEGIN_SRC emacs-lisp :noweb-ref hydra
(defhydra hydra-projectile
  (:color teal :hint nil)
  "
  PROJECTILE: %(projectile-project-root)

  ^Find File^        ^Search/Tags^        ^Buffers^         ^Cache^                      ^Project^
  ^---------^        ^-----------^        ^-------^         ^-----^                      ^-------^
  _f_: file          _R_: grep            _i_: Ibuffer      _c_: cache clear             _p_: switch proj
  _F_: file dwim     _g_: update gtags    _b_: switch to    _x_: remove known project
  _C-f_: file pwd    _o_: multi-occur     _s-k_: Kill all   _X_: cleanup non-existing
  _r_: recent file   ^ ^                  ^ ^               _z_: cache current
  _d_: dir
"
  ("R"   counsel-projectile-rg)
  ("b"   counsel-projectile-switch-to-buffer)
  ("c"   projectile-invalidate-cache)
  ("d"   counsel-projectile-find-dir)
  ("f"   counsel-projectile-find-file)
  ("F"   counsel-projectile-find-file-dwim)
  ("C-f" projectile-find-file-in-directory)
  ("g"   ggtags-update-tags)
  ("s-g" ggtags-update-tags)
  ("i"   projectile-ibuffer)
  ("K"   projectile-kill-buffers)
  ("s-k" projectile-kill-buffers)
  ("m"   projectile-multi-occur)
  ("o"   projectile-multi-occur)
  ("p"   counsel-projectile-switch-project)
  ("r"   projectile-recentf)
  ("x"   projectile-remove-known-project)
  ("X"   projectile-cleanup-known-projects)
  ("z"   projectile-cache-current-file)
  ("q"   nil "cancel" :color blue))

(bind-key "C-c p" #'hydra-projectile/body)
#+END_SRC
*** Visual Regexp
#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :ensure nil
  :commands (vr/replace vr/query-replace))
#+END_SRC
*** Screencast
#+BEGIN_SRC emacs-lisp
(autoload 'gif-screencast "gif-screencast" "Start GIF Screencast" t)
(autoload 'keycast-mode "keycast" "Start `keycast-mode'" t)

(defun gm/begin-screencast ()
  (interactive)
  (gif-screencast)
  (unless (bound-and-true-p keycast-mode) (keycast-mode)))

(defun gm/end-screencast ()
  (interactive)
  (gif-screencast-stop)
  (when (bound-and-true-p keycast-mode) (keycast-mode)))

(bind-key "<f8>" #'gm/begin-screencast)
(bind-key "<f9>" #'gm/end-screencast)
#+END_SRC
*** Key Frequency
#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :defer 2
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1)
  :custom
  (keyfreq-file "~/emacs-keyfreq"))
#+END_SRC
*** El-patch
Properly patch functions.
#+BEGIN_SRC emacs-lisp
(use-package el-patch
  :commands (el-patch-defun))
#+END_SRC
*** Transmission
Simple client for =transmission-cli=.
#+BEGIN_SRC emacs-lisp
(use-package transmission
  :commands (transmission transmission-add)
  :config (add-to-list 'transmission-refresh-modes 'transmission-mode)
  :bind (:map transmission-mode-map
              ("T" . transmission-toggle-limits)))
#+END_SRC
I often want to download large torrents to my external drive if possible.
#+BEGIN_SRC emacs-lisp
(defun gm/transmission-add (url)
  (let* ((torrent-dir-cand (expand-file-name "download" gm--drive-path))
         (torrent-dir (when (file-directory-p torrent-dir-cand) torrent-dir-cand)))
  (transmission-add url torrent-dir)))
#+END_SRC
*** Spray
Spray is a speed-reading package for Emacs.
#+BEGIN_SRC emacs-lisp
(use-package spray
  :hook ((spray-mode . (lambda () (beacon-mode -1)))
         (spray-mode . olivetti-mode))
  :custom
  (spray-margin-top 5)
  (spray-margin-left 1.5))
#+END_SRC
*** Togetherly
#+BEGIN_SRC emacs-lisp
(use-package togetherly
  :commands (togetherly-server-start togetherly-client-start))
#+END_SRC
* Keybindings
** Better Defaults
These are what I think are better bindings for or better versions of the default
commands.
*** Easy M-x
Alt is simply too hard to hit for such a commonly used command.
#+BEGIN_SRC emacs-lisp
(bind-key "C-SPC" #'execute-extended-command)
#+END_SRC
*** Set Mark
Need a replacement because we rebound ~C-SPC~ above. And I know, I know, everyone
loves =transpose-chars=, but I don't see myself using it that much.
#+BEGIN_SRC emacs-lisp
(bind-key "C-t" #'set-mark-command)
#+END_SRC
*** Shell Kill Word
Use the standard Unix shell binding for deleting the previous word. As a result,
it's fine to remove the default Emacs bindings for this. In fact,
=C-<backspace>= in particular can get in the way.
#+BEGIN_SRC emacs-lisp
(bind-key "C-w" #'backward-kill-word)
(unbind-key "C-<backspace>")
(unbind-key "M-DEL")
#+END_SRC
*** Kill Paragraph
This binding takes after the default =M-k= binding for =kill-sentence=.
#+BEGIN_SRC emacs-lisp
(bind-key "M-K" #'kill-paragraph)
#+END_SRC
*** Browse Kill Ring
This used to be a feature of Emacs.
#+BEGIN_SRC emacs-lisp
(use-package browse-kill-ring
  :commands browse-kill-ring
  :bind ("M-y" . browse-kill-ring)
  :config (browse-kill-ring-default-keybindings))
#+END_SRC
*** Unfill Paragraph
I used to =[remap fill-paragraph]= to a function that toggled the paragraph from
filled to unfilled with a single key. It turned out this was not best for my use
case, as I usually double-tapped =M-q= because I just wanted to refill the
paragraph. However, unfilling is sometimes useful, so I kept the package around.
#+BEGIN_SRC emacs-lisp
(use-package unfill
  :commands unfill-paragraph
  :bind ("M-Q" . unfill-paragraph))
#+END_SRC
*** Join Line
This allows me to combine text over multiple lines into one line.
#+BEGIN_SRC emacs-lisp
(defun gm/join-line ()
  (interactive)
  (join-line -1))

(bind-key "M-j" #'gm/join-line)
#+END_SRC
*** Normal Undo Binding
#+BEGIN_SRC emacs-lisp
(bind-key "C-z" 'undo)
(bind-key "C-x C-u" 'undo)
#+END_SRC
*** Better Narrowing
From [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Emacs narrow-or-widen-dwim]].
#+BEGIN_SRC emacs-lisp
(defun narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning)
                           (region-end)))
        ((derived-mode-p 'org-mode)
         (cond ((ignore-errors (org-edit-src-code) t)
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        (t (narrow-to-defun))))

(bind-key "n" #'narrow-or-widen-dwim ctl-x-map)
#+END_SRC
Then we can use =narrow-or-widen-dwim= to easily edit org =src= blocks.
#+BEGIN_SRC emacs-lisp
(after! org-src
  (bind-key "C-x C-s" #'org-edit-src-exit org-src-mode-map))
#+END_SRC
*** Delete Better
When using =C-d= or =Backspace=, delete all white space in a certain direction, and
not just one.
#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
  :commands hungry-delete-mode
  :hook (text-mode . hungry-delete-mode))
#+END_SRC
*** Better Buffers
Kill better.
#+BEGIN_SRC emacs-lisp
(defun bjm/kill-this-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))

(bind-key "C-x k" 'bjm/kill-this-buffer)
#+END_SRC
Exterminate better.
#+BEGIN_SRC emacs-lisp
(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer)))
    (if (not (and filename (file-exists-p filename)))
        (kill-buffer buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(bind-key "C-x C-k" #'delete-current-buffer-file)
#+END_SRC
Rename better (from Magnar Sveen).
#+BEGIN_SRC emacs-lisp
(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file." name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(bind-key "C-x C-r" #'rename-current-buffer-file)
#+END_SRC
Switch better.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x b" #'ivy-switch-buffer)
#+END_SRC
Use =ibuffer=.
#+BEGIN_SRC emacs-lisp
(autoload 'ibuffer "ibuffer" "List buffers." t)
(bind-key "C-x C-b" 'ibuffer)
#+END_SRC
*** Unbind Fill Column
I never use this command but keep accidentally hitting it instead of =C-x C-f=.
#+BEGIN_SRC emacs-lisp
(unbind-key "C-x f")
#+END_SRC
*** Delete Frame
The default =C-x 5 0= is too clunky for this.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x w" #'delete-frame)
#+END_SRC
*** Comment Dwim
A better version of the built-in =comment-dwim= from [[https://github.com/remyferre/comment-dwim-2][remyferre/comment-dwim-2]].
#+BEGIN_SRC emacs-lisp
(use-package comment-dwim-2
  :commands comment-dwim-2
  :bind (("M-;" . comment-dwim-2)))
#+END_SRC
** Find Inbox
#+BEGIN_SRC emacs-lisp
(bind-key "C-c o" (lambda! (find-file "~/org/inbox.org")))
#+END_SRC
** Keychord
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package key-chord
  :ensure nil
  :demand t
  :config
  (key-chord-mode 1)
  <<keychord>>)
#+END_SRC
*** Number Symbols
Eliminate the shift key for inputting symbols. The dollar sign ($) keychord is
especially useful when typing LaTeX.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref keychord
(key-chord-define-global "1q" "!")
(key-chord-define-global "2w" "@")
(key-chord-define-global "3e" "#")
(key-chord-define-global "4r" "$")
(key-chord-define-global "5t" "%")
(key-chord-define-global "6y" "^")
(key-chord-define-global "6t" "^")
(key-chord-define-global "7y" "&")
(key-chord-define-global "8u" "*")
(key-chord-define-global "9i" "(")
(key-chord-define-global "0o" ")")
(key-chord-define-global "-p" "_")
(key-chord-define-global "[=" "+")
#+END_SRC
** Toggles
We use a hydra to toggle various features in our setup. I bind the keys in my
section for the [[*Context-dependent Hydra][Context-dependent Hydra]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-toggle (:color pink)
  "
_t_ theme-colour       %`gm/theme
_m_ quick-math-mode:   %`quick-math-mode
_p_ equation-preview:  %`gm/eq-preview-mode
_e_ pretty-math:       %`pretty-math-mode
_D_ dubcaps-mode:      %`gm/dubcaps-mode
_W_ Window management
"
  ("t" gm/switch-theme nil)
  ("m" quick-math-mode nil :color blue)
  ("p" gm/eq-preview-mode nil)
  ("e" pretty-math-mode nil)
  ("D" gm/dubcaps-mode nil)
  ("W" hydra-window-mngm/body :color blue)
  ("q" nil "cancel"))
#+END_SRC
I also link to window management here.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defun shrink-frame-horizontally (&optional increment)
  (interactive "p")
  (let ((frame (window-frame)))
    (set-frame-width frame (- (frame-width frame) increment))))
(defun enlarge-frame-horizontally (&optional increment)
  (interactive "p")
  (let ((frame (window-frame)))
    (set-frame-width frame (+ (frame-width frame) increment))))
(defun shrink-frame-vertically (&optional increment)
  (interactive "p")
  (let ((frame (window-frame)))
    (set-frame-height frame (- (frame-height frame) increment))))
(defun enlarge-frame-vertically (&optional increment)
  (interactive "p")
  (let ((frame (window-frame)))
    (set-frame-height frame (+ (frame-height frame) increment))))

(defun shift-frame-right (&optional increment)
  (interactive "P")
  (unless increment (setq increment 20))
  (set-frame-parameter nil 'left (+ (frame-parameter nil 'left) increment)))
(defun shift-frame-left (&optional increment)
  (interactive "P")
  (unless increment (setq increment 20))
  (message "user-pos:" (frame-parameter nil 'user-position))
  (set-frame-parameter nil 'left (- (frame-parameter nil 'left) increment)))
(defun shift-frame-up (&optional increment)
  (interactive "P")
  (unless increment (setq increment 20))
  (set-frame-parameter nil 'top (- (frame-parameter nil 'top) increment)))
(defun shift-frame-down (&optional increment)
  (interactive "P")
  (unless increment (setq increment 20))
  (set-frame-parameter nil 'top (+ (frame-parameter nil 'top) increment)))

(defhydra hydra-window-mngm (:color pink :hint nil)
  "
frame    ^ ^ _i_ ^ ^    frame   ^ ^ _z_ ^ ^    window   ^ ^ _w_
sizing:  _j_ ^ ^ _l_    moving: _g_ ^ ^ _h_    sizing:  _a_ ^ ^ _s_
         ^ ^ _k_ ^ ^            ^ ^ _b_ ^ ^             ^ ^ _y_
"
  ("a" shrink-window-horizontally)
  ("s" enlarge-window-horizontally)
  ("y" enlarge-window)
  ("w" shrink-window)
  ("j" shrink-frame-horizontally)
  ("l" enlarge-frame-horizontally)
  ("k" shrink-frame-vertically)
  ("i" enlarge-frame-vertically)
  ("g" shift-frame-left)
  ("h" shift-frame-right)
  ("z" shift-frame-up)
  ("b" shift-frame-down)
  ("q" nil "quit" :color blue))
#+END_SRC
* Org Mode
We have to require the entire =org.el= file to get ~ox-hugo~ to work properly.
#+BEGIN_SRC emacs-lisp :noweb no-export
(after! org
  <<org-settings>>
  (bind-keys :map org-mode-map
             <<org-keys>>))
#+END_SRC
** Configuration
*** Speed Keys
This mode binds Org Mode commands to single character sequences, as long as you
are at the beginning of an Org headline.
#+BEGIN_SRC emacs-lisp
(setq org-use-speed-commands t)
#+END_SRC
We customize the commands a bit.
#+BEGIN_SRC emacs-lisp
(setq org-speed-commands-user
      '(("j" counsel-org-goto)
        ("a" org-archive-subtree)
        ("c" org-set-tags-command)
        ("d" (lambda () (interactive) (org-todo 'done)))
        ("R" (lambda () (interactive) (org-todo "TOREAD") (gm/refile (expand-file-name "reading.org" org-directory) "Reading")))))
#+END_SRC
*** Invisible Edits
When text is entered near a hidden area (...), it is hard to see what is
changed.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-catch-invisible-edits 'show-and-error)
#+END_SRC
*** Better Return Behaviour
A better return for Org mode. If in a list, we want to add a new item.
If we're in a heading, we want to go the end of the line, then return. This is
because I never want to split the heading in half. If we're in a table, we add a
new row. If we are in a source block, we want to indent. Inspired by [[http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/][John Kitchin]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun gm/org-return (&optional ignore)
  "Add new list item, heading or table row with RET.
A double return on an empty element deletes it.
Use a prefix arg to get regular RET. "
  (interactive "P")
  (if ignore
      (org-return)
    (cond
     ((eq 'link (car (org-element-context)))
      (org-return))
     ((and (org-in-item-p) (not (bolp)))
      (if (org-element-property :contents-begin (org-element-context))
          (org-insert-item)
        (beginning-of-line)
        (setf (buffer-substring
               (line-beginning-position) (line-end-position)) "")
        (org-return)))
     ((org-at-heading-p)
      (end-of-line)
      (org-return))
     ((org-at-table-p)
      (if (-any?
           (lambda (x) (not (string= "" x)))
           (nth
            (- (org-table-current-dline) 1)
            (org-table-to-lisp)))
          (org-return)
        ;; empty row
        (beginning-of-line)
        (setf (buffer-substring
               (line-beginning-position) (line-end-position)) "")
        (org-return)))
     ((org-in-src-block-p)
      (newline-and-indent))
     (t
      (org-return)))))
#+END_SRC
We replace the normal return.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(bind-key "RET" #'gm/org-return org-mode-map)
(bind-key "C-RET" #'org-return org-mode-map)
#+END_SRC
*** File Locations
We need a place where Org files go by default. Org Mode uses this to, for
example, decide where to put the result of an Org Capture.
#+BEGIN_SRC emacs-lisp
(setq org-directory "~/org/")
#+END_SRC
We similarly decide other default locations.
#+BEGIN_SRC emacs-lisp
(setq gm/agenda-org-files '("todo" "notes" "gcal" "reading")
      org-default-notes-file (expand-file-name "inbox.org" org-directory)
      org-agenda-files (append
                        `(,org-default-notes-file)
                        (--map (expand-file-name (concat it ".org") org-directory)
                               gm/agenda-org-files)))
#+END_SRC
This is particular to my setup, but I want my agenda to include the non-archived portion
of my school files.
#+BEGIN_SRC emacs-lisp
(require 'org-agenda)

(when (file-exists-p "~/school/")
  (setq org-agenda-files
      (append org-agenda-files
              (apply 'append
                     (mapcar
                      (lambda (directory)
                        (directory-files-recursively
                         directory org-agenda-file-regexp))
                      (--filter (not (string-match-p (regexp-opt '("archive" "." "..")) it))
                                (directory-files "~/school" t)))))))
#+END_SRC
Keeping my refile locations minimal makes refiling faster; besides, my primary
use case for refiling is to stow something away in its proper place for later
use. and we just set our "proper places."
#+BEGIN_SRC emacs-lisp
(setq gm/org-non-refile-targets '("inbox" "gcal")
      gm/org-refile-targets (--filter
                              (not (string-match-p
                                    (concat (regexp-opt gm/org-non-refile-targets) ".org$") it))
                              org-agenda-files)
      org-refile-targets '((nil :maxlevel . 5)
                           (gm/org-refile-targets :maxlevel . 5)))
#+END_SRC
Sometimes we want to refile into a subtree that hasn't yet been created.
#+BEGIN_SRC emacs-lisp
(setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC
This abbreviation lets us easily include attached files as inline images.
#+BEGIN_SRC emacs-lisp
(setq org-link-abbrev-alist '(("att" . org-attach-expand-link)))
#+END_SRC
*** Refile and Archival
Log refiling.
#+BEGIN_SRC emacs-lisp
(setq org-log-refile 'time)
#+END_SRC
Don't refile to DONE tasks.
#+BEGIN_SRC emacs-lisp
(defun gm/verify-refile-target ()
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))

(setq org-refile-target-verify-function 'gm/verify-refile-target)
#+END_SRC
Cache the refile targets. It can be refreshed with =C-u C-u C-u C-u C-w=.
#+BEGIN_SRC emacs-lisp
(setq org-refile-use-cache t)
#+END_SRC
Refile to a given location.
#+BEGIN_SRC emacs-lisp
(defun gm/refile (file headline)
  (let ((curr-buff (buffer-name))
        (pos (save-excursion
               (find-file file)
               (org-find-exact-headline-in-buffer headline))))
    (org-refile nil nil (list headline file nil pos))
    (switch-to-buffer curr-buff)))
#+END_SRC
I often have a bunch of files I need to organize, such as scanned papers or
documents sitting in my downloads folder. Invoking =org-attach= from each target
is a lot of tedious work, so I made this snippet that lets me do it all from a
Dired buffer.
#+BEGIN_SRC emacs-lisp
(defun gm--attach-name (file title)
  (concat (replace-regexp-in-string " " "-" (downcase title)) "." (f-ext file)))

(defun gm--attach-to-subtree (file &optional new-filename rfloc)
  (unless rfloc (setq rfloc (org-refile-get-location nil nil t)))
  (unless new-filename (setq new-filename (gm--attach-name file (read-string "Title: "))))
  (let* ((target (nth 1 rfloc))
        (mark-maybe (nth 3 rfloc))
        (mark (if (markerp mark-maybe)
                  (marker-position mark-maybe)
                mark-maybe))
        (new-file (expand-file-name new-filename (f-dirname file)))
        (old-buff (current-buffer))
        title)
    (condition-case nil
        (rename-file file new-file)
      (error nil))
    (find-file target)
    (goto-char mark)
    (org-attach-attach new-file)
    (switch-to-buffer old-buff)))

(defun gm/dired-attach-files ()
  (interactive)
  (let ((list (dired-get-marked-files)))
    (delete-other-windows)
    (find-file-other-window (dired-file-name-at-point))
    (other-window 1)
    (while list
      (org-refile 0)
      (other-window 1)
      (delete-window)
      (find-file-other-window (dired-file-name-at-point))
      (when (eq major-mode 'pdf-view-mode)
        (pdf-view-first-page))
      (other-window 1)
      (gm--attach-to-subtree (dired-file-name-at-point))
      (!cdr list)
      (when list
        (dired-next-marked-file 1)))))
#+END_SRC
[[https://orgmode.org/worg/org-hacks.html#org0344577][Worg]] gives a way to avoid messing up the heading hierarchy of an archive file
after archiving lower level items.
#+BEGIN_SRC emacs-lisp
(defun gm/org-inherited-no-file-tags ()
  (let ((tags (org-entry-get nil "ALLTAGS" 'selective))
        (ltags (org-entry-get nil "TAGS")))
    (mapc (lambda (tag)
            (setq tags
                  (replace-regexp-in-string (concat tag ":") "" tags)))
          (append org-file-tags (when ltags (split-string ltags ":" t))))
    (if (string= ":" tags) nil tags)))

(defadvice org-archive-subtree (around my-org-archive-subtree-low-level activate)
  (let ((tags (gm/org-inherited-no-file-tags))
        (org-archive-location
         (if (save-excursion (org-back-to-heading)
                             (> (org-outline-level) 1))
             (concat (car (split-string org-archive-location "::"))
                     "::* "
                     (car (org-get-outline-path)))
           org-archive-location)))
    ad-do-it
    (with-current-buffer (find-file-noselect (org-extract-archive-file))
      (save-excursion
        (while (org-up-heading-safe))
        (org-set-tags-to tags)))))
#+END_SRC
*** Capture
:PROPERTIES:
:ORDERED:  t
:END:
Org Capture is one of the best features of Org Mode. I use it to organize my
todo list, take note of ideas I think of, and kickstart blog posts.
#+BEGIN_SRC emacs-lisp
(bind-key "C-c c" #'org-capture)
#+END_SRC
I want to start captures in new frames.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(require 'org-capture-pop-frame)
#+END_SRC
Here are my capture templates.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-capture-templates
      `(("a" "Appointment" entry
         (file ,(expand-file-name "gcal.org" org-directory))
         "* %^{Title} \n%^T\n"
         :immediate-finish t)
        ("t" "Todo" entry
         (file org-default-notes-file)
         "* TODO %^{Title}\n:PROPERTIES:\n:CREATED: %U\n:END:\n%i%?")
        ("n" "Note" entry
         (file org-default-notes-file)
         "* %^{Title}\n:PROPERTIES:\n:CREATED: %U\n:END:\n%i%?")
        ("j" "Journal" entry
         (file+olp+datetree ,(expand-file-name "journal.org" org-directory))
         "** %^{Heading}\n:PROPERTIES:\n:CREATED: %U\n:END:")
        ("e" "euler" entry
         (file+headline "~/website/content-org/blog.org" "Euler")
         "** Project Euler %^{Problem Number}: %^{Problem Name} %^g
:PROPERTIES:
:EXPORT_FILE_NAME: %\\1
:EXPORT_DATE: %u
:EXPORT_DESCRIPTION: My solution to problem %\\1 of Project Euler.
:END:\n*** Problem Statement\n%?\n*** My Algorithm")))
#+END_SRC
The two applications I spend the most time in are Emacs and the browser (I use
qutebrowser). It would be very nice if I could use Org Capture from within the
web browser. In particular, I want to be able to rely on the functionality of
Org Mode to manage my bookmarks (see [[https://karl-voit.at/2014/08/10/bookmarks-with-orgmode/][Karl Volt's method]]), rather than rely on
the browser. Also, I often come across quotes or excerpts that I'd love to file
away for later. The built-in =org-protocol= lets us intercept calls to =emacsclient=
from a web browser and apply functions to it, like =org-capture=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(require 'org-protocol)
#+END_SRC
However, this only lets us manipulate the selection in the browser as plain
text. Pretty much every browser has the ability to copy text as HTML. So we
leverage the power of =pandoc= to convert this HTML to Org Mode syntax using some
code by [[https://github.com/alphapapa/org-protocol-capture-html][alphapapa]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(require 'org-protocol-capture-html)
#+END_SRC
So how do we actually get data from the outside world into Emacs? The [[https://orgmode.org/worg/org-contrib/org-protocol.html][Org
Mode wiki]] has the basics. The meat of the following snippet is in the function
that turns the browser selection into HTML (after =&body==). It was sourced from
[[https://stackoverflow.com/questions/5643635/how-to-get-selected-html-text-with-javascript/6668159#6668159][StackOverflow]].
#+BEGIN_SRC js :tangle no
javascript:location.href='org-protocol://capture-html?template=p&url=' + encodeURIComponent(location.href) + '&title=' + encodeURIComponent(document.title || '[untitled page]') + '&body=' + encodeURIComponent(function () {var html = ''; if (typeof document.getSelection != 'undefined') {var sel = document.getSelection(); if (sel.rangeCount) {var container = document.createElement('div'); for (var i = 0, len = sel.rangeCount; i < len; ++i) {container.appendChild(sel.getRangeAt(i).cloneContents());} html = container.innerHTML;}} else if (typeof document.selection != 'undefined') {if (document.selection.type == 'Text') {html = document.selection.createRange().htmlText;}} var relToAbs = function (href) {var a = document.createElement('a'); a.href = href; var abs = a.protocol + '//' + a.host + a.pathname + a.search + a.hash; a.remove(); return abs;}; var elementTypes = [['a', 'href'], ['img', 'src']]; var div = document.createElement('div'); div.innerHTML = html; elementTypes.map(function(elementType) {var elements = div.getElementsByTagName(elementType[0]); for (var i = 0; i < elements.length; i++) {elements[i].setAttribute(elementType[1], relToAbs(elements[i].getAttribute(elementType[1])));}}); return div.innerHTML;}());
#+END_SRC
I bind this to =c b=, for "capture bookmark." The data goes to the following template.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(add-to-list
 'org-capture-templates
 '("p" "Org Protocol" entry
   (file org-default-notes-file)
   "* %^{Title|%(gm/square-to-round-brackets \"%:description\")} :web:
:PROPERTIES:
:CREATED: %U
:SOURCE: [[%:link][%(gm/square-to-round-brackets \"%:description\")]]
:END:
%?\n%(->> \"%i\" gm/fix-mathjax-output gm/quote-if-non-empty)"))
#+END_SRC
I have a similar template for capturing code snippets.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(add-to-list
 'org-capture-templates
 '("c" "Org Protocol Code" entry
   (file org-default-notes-file)
   "* %^{Title} :snippet:\n:PROPERTIES:\n:SOURCE: [[%:link][%(gm/square-to-round-brackets \"%:description\")]] \n:CREATED: %U\n:END:\n%?\n#+BEGIN_SRC %^{Language|emacs-lisp|python|sh|conf}\n%(hex-to-string \"%i\")\n#+END_SRC"))
#+END_SRC
Because Org links are constructed with square brackets, any URL whose title
contains square brackets (I'm looking at you, arXiv) would break a normal
implementation of the this template. Our workaround is to change square brackets
to round ones.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun gm/square-to-round-brackets (s)
  "Transform [ into ( and ] into ), other chars left unchanged."
  (->> s
      (replace-regexp-in-string "\\[" "\(")
      (replace-regexp-in-string "\\]" "\)")))
#+END_SRC
Also, I want to wrap the excerpt in an Org quote block, but not if there is no
excerpt.
#+BEGIN_SRC emacs-lisp
(defun gm/quote-if-non-empty (str)
  (setq str (with-temp-buffer
              (insert (s-trim str))
              (fill-region (point-min) (point-max))
              (buffer-string)))
  (unless (or (string-blank-p str) ;; dont quote things with headings or org blocks
              (string-match-p "\\(^ \\**\\)\\|\\(#\\+BEGIN_\\)" str))
    (setq str (format "#+BEGIN_QUOTE\n%s\n#+END_QUOTE" str)))
  (s-trim str))
#+END_SRC
Copying MathJax is a little strange. It pastes in the form =A$B$$B'$=, where =A=
contains no spaces and is a Unicode representation of the LaTeX string, and =B=
and =B'= are slight variants of the actual LaTeX string. I'm not quite certain
what the differences between =B= and =B'= are. They both seem to be functional, but
=B'= generally seems to be better. For example, =B= might contain =a^{n}= and =\lbrack 0,1
\rbrack=, while =B'= has =a^n= and =[0,1]=. This function runs a simple regex replace
for =B'=.
#+BEGIN_SRC emacs-lisp
(defun gm/fix-mathjax-output (str)
  (let ((re "[^ $]*\$[^$]*\$\$\\([^$]*\\)\\$"))
    (replace-regexp-in-string re "\\\\(\\1\\\\)" str)))
#+END_SRC
I also bind =c l= to store the URL of the current page as an Org link.
#+BEGIN_SRC js :tangle no
javascript:location.href='org-protocol://store-link:?url='+encodeURIComponent(location.href)
#+END_SRC
Finally, I have a general purpose binding on =c n= for capturing any notes or
thoughts that come to me while browsing.
#+BEGIN_SRC js :tangle no
javascript:location.href='org-protocol://capture?template=n'
#+END_SRC
I bind =c p= as a specific case of =c b= for PDF files. The following function
fetches the path of the current PDF file in qutebrowser's temporary download directory.
#+BEGIN_SRC emacs-lisp
(defun gm/find-qutebrowser-download (url)
  (let* ((qutedir (expand-file-name (car
                                     (--filter (string-match "qutebrowser-downloads" it)
                                               (directory-files "/tmp/"))) "/tmp"))
         (file (progn (string-match "\\(tmp.*\\.pdf\\)" url)
                      (substring url (match-beginning 1) (match-end 1)))))
    (expand-file-name file qutedir)))
#+END_SRC
This template attaches the file for future reference.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(add-to-list
 'org-capture-templates
 '("q" "Org Protocol Qutebrowser pdf" entry
   (file org-default-notes-file)
   "* %^{Title} %(let* ((dir \"~/org/data\") (org-attach-directory dir)) (require 'org-attach)
(org-attach-attach (gm/find-qutebrowser-download \"%:description\") nil 'cp) \"\")\n:PROPERTIES:\n:CREATED: %U %^{Author}p\n:END:\n%?\n"))
#+END_SRC
*** Org Download
Now we can easily move images into Org Mode buffers.
#+BEGIN_SRC emacs-lisp
(use-package org-download
  :commands (org-download-yank)
  :config
  (org-download-enable)
  :custom
  (org-download-method 'attach)
  (org-download-timestamp t) (org-download-screenshot-method "scrot -s"))
#+END_SRC
**** Add Images to Notes Live
[[http://pragmaticemacs.com/emacs/a-workflow-to-quickly-add-photos-to-org-mode-notes/][This article]] gives a neat way to add images taken from your phone into an Org
Mode buffer. This could be useful if you are taking notes in a class or
conference and want to reference a slide or diagram on the board.

I use Syncthing to get photos from my phone to my computer, but any syncing
service works, like Google Drive or Dropbox.
#+BEGIN_SRC emacs-lisp
(defvar gm/live-image-dir (expand-file-name "~/Camera/Camera"))
#+END_SRC
We use =ivy= to prompt the user for a file from the camera roll, sorted by most
recent. Then, we attach the file to the current subtree by /copying/ it, add an
image link, and display it. Because most images taken this way are vertical, I
rotate the image first to make sure it displays correctly.
#+BEGIN_SRC emacs-lisp
(defun gm/insert-live-image ()
  (interactive)
  (let (file-list file-list-sorted start-file start-file-full end-file)
    (setq file-list
          (-remove (lambda (x) (nth 1 x))
                   (directory-files-and-attributes gm/live-image-dir)))
    (setq file-list-sorted
          (mapcar #'car
                  (sort file-list
                        #'(lambda (x y) (time-less-p (nth 6 y) (nth 6 x))))))
    (setq start-file (ivy-read
                      "Select file to attach:"
                      file-list-sorted
                      :re-builder #'ivy--regex
                      :sort nil
                      :initial-input nil))
    (setq start-file-full
          (expand-file-name start-file gm/live-image-dir))
    (org-attach-attach start-file-full nil 'cp)
    (message "Attached %s" start-file-full)
    (setq end-file (expand-file-name start-file (org-attach-dir nil)))
    (call-process "convert" nil nil nil end-file "-rotate" "-90" end-file)
    (insert (org-make-link-string (format "file:%s" end-file)))
    (org-display-inline-images t t)))
#+END_SRC
*** Todo Lists and Agenda
I like the following set of =TODO= words. This is what appears
before an Org headline when a todo state is activated.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-todo-keywords
      '((sequence "TODO(t!)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")
        (sequence "TOREAD(r!)" "READING(R)" "|" "READ(b)")))
#+END_SRC
Automatically archive cancelled tasks.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-todo-state-tags-triggers '(("CANCELLED" ("ARCHIVE" . t))))
#+END_SRC
Track when a heading is added already in TODO state.
#+BEGIN_SRC emacs-lisp
(setq org-trest-insert-todo-heading-as-state-change t)
#+END_SRC
Track the time when a TODO item is marked DONE.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-log-done 'time)
#+END_SRC
Do something similar for other properties.
#+BEGIN_SRC emacs-lisp
(setq org-log-reschedule 'time
      org-log-redeadline 'time
      org-log-clock-out 'time)
#+END_SRC
Because I make a lot of logs, I want to file them away into the LOGBOOK drawer.
#+BEGIN_SRC emacs-lisp
(setq org-log-into-drawer t)
#+END_SRC
I would rather the progress in a todo list (for example, [4/5]) be automatically
updated when I archive a subtree.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun myorg-update-parent-cookie ()
  (when (equal major-mode 'org-mode)
    (save-excursion
      (ignore-errors
        (org-back-to-heading)
        (org-update-parent-todo-statistics)))))

(defadvice org-archive-subtree (after fix-cookies activate)
  (myorg-update-parent-cookie))
#+END_SRC
If all the checkboxes in a list are checked, the parent heading is done, and its
TODO state should be marked as such.
#+BEGIN_SRC emacs-lisp
(eval-after-load 'org-list
  '(add-hook 'org-checkbox-statistics-hook (function ndk/checkbox-list-complete)))

(defun ndk/checkbox-list-complete ()
  (save-excursion
    (org-back-to-heading t)
    (let ((beg (point)) end)
      (end-of-line)
      (setq end (point))
      (goto-char beg)
      (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]" end t)
            (if (match-end 1)
                (if (equal (match-string 1) "100%")
                    ;; all done - do the state change
                    (org-todo 'done)
                  (org-todo 'todo))
              (if (and (> (match-end 2) (match-beginning 2))
                       (equal (match-string 2) (match-string 3)))
                  (org-todo 'done)
                (org-todo 'todo)))))))
#+END_SRC
I manage deadlines with Org Agenda.
#+BEGIN_SRC emacs-lisp
(bind-key "C-c a" #'org-agenda)
#+END_SRC
I've never used these commands on purpose.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(unbind-key "C-c [" org-mode-map)
#+END_SRC
The default is =week=, which gives the current week (starting on Monday by
default). I prefer to see a larger view.
#+BEGIN_SRC emacs-lisp
(setq org-agenda-span 14)
#+END_SRC
However, that's not quite enough, because when I'm out and about, I want whatever
I have in my Org Agenda to be able to alert me on my phone. I also want to be
able to enter new events on the go. The best solution I've found for this is to
integrate Org Mode with Google Calendar. The setup is contained in the file for
my personal settings, =private.el=. Once you've set it up, you can find your
calendar's private and secret IDs from [[https://console.developers.google.com/apis/credentials][this link]] (Google).
#+BEGIN_SRC emacs-lisp
(use-package org-gcal
  :after org
  :commands org-gcal-sync
  :init (setq package-check-signature nil)
  :custom (org-gcal-dir gmacs-cache-dir)
  :hook (org-agenda-mode . org-gcal-sync))
#+END_SRC
*** Links
I often use links to easily navigate to a relevant file in cases where I would
rather not use =org-attach=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c l" . org-store-link)
#+END_SRC
Follow links using return rather than =C-c C-o=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-return-follows-link t)
#+END_SRC
I can use =org-cliplink= to paste in a website's URL with the link's description
being the title of that website.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(use-package org-cliplink
  :commands org-cliplink
  :bind (:map org-mode-map ("C-c y" . org-cliplink)))
#+END_SRC
*** Word Count
It's very useful to be able to see the word count of a subtree when I am writing
a paper for school.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(use-package org-wc
  :commands org-wc-display
  :bind (:map org-mode-map ("C-c w" . gm/wc-display-current-subtree)))
#+END_SRC
I narrow to subtree by default because displaying the count for every subtree in
the file is (usually) unnecessary and (always) too slow.
#+BEGIN_SRC emacs-lisp
(after! org-wc
  (defun gm/wc-display-current-subtree (arg)
    (interactive "P")
    (if arg
        (org-wc-display nil)
      (save-restriction
        (org-narrow-to-subtree)
        (org-wc-display nil)))))
#+END_SRC
*** Org Ref
A wonderfully featured framework for maintaining bibliographies and writing
academic papers in Org Mode by Org-guru John Kitchin.
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package org-ref)
(setq org-ref-completion-library 'org-ref-ivy-cite)
(autoload #'org-ref-insert-link "org-ref")
(autoload #'org-ref-bibtex-new-entry/body "org-ref")
(add-hook 'bibtex-mode-hook (lambda () (require 'org-ref)))

(after! org-ref
  (require 'doi-utils)
  (require 'org-ref-pdf)
  (bind-key "C-c b" #'org-ref-bibtex-new-entry/body bibtex-mode-map)
  <<org-ref>>)
#+END_SRC
For humanities essays.
#+BEGIN_SRC emacs-lisp
(defun gm/org-ref-cite-with-page ()
  (interactive)
  (if current-prefix-arg
      (call-interactively #'org-ref-insert-link)
    (insert "[[")
    (call-interactively #'org-ref-insert-link)
    (insert "][")
    (insert (read-string "Page number: "))
    (insert "]] ")))
#+END_SRC
Bind this in Org Mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(bind-key "C-c ]" #'org-ref-insert-link org-mode-map)
#+END_SRC
Keep everything in my org directory.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-ref
(setq org-ref-bibliography-notes (expand-file-name "ref/notes.org" org-directory)
      org-ref-default-bibliography (list (expand-file-name "ref/references.bib" org-directory)
                                         (expand-file-name "ref/zotero.bib" org-directory))
      org-ref-pdf-directory (expand-file-name "ref/pdf/" org-directory))
#+END_SRC
Use =ivy= instead of =helm= for =org-ref= completion. It makes everything more
cohesive, as I use =ivy= everywhere else.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-ref
(setq org-ref-completion-library 'org-ref-ivy-cite)
#+END_SRC
Whether it's side citations or footnotes, I almost always use the =\footcite=
macro in LaTeX.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-ref
(setq org-ref-default-citation-link "footcite")
#+END_SRC
It's >=2019. BibTeX is a thing of the past.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-ref
(setq bibtex-dialect 'biblatex)
#+END_SRC
Format the automatically generated keys.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-ref
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
#+END_SRC
I'm not entirely sure what this file does or how useful it is, but I didn't want
it cluttering up my home directory.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-ref
(setq orhc-bibtex-cache-file (expand-file-name ".orhc-bibtex-cache" gmacs-cache-dir))
#+END_SRC
Redefine: Small modification to how files are attached to bib entries. I want the default
directory to be my downloads folder.
#+BEGIN_SRC emacs-lisp
(after! org-ref
  (defun org-ref-bibtex-assoc-pdf-with-entry (&optional prefix)
    "Prompt for pdf associated with entry at point and rename it.
Check whether a pdf already exists in `org-ref-pdf-directory' with the
name '[bibtexkey].pdf'. If the file does not exist, rename it to
'[bibtexkey].pdf' using
`org-ref-bibtex-assoc-pdf-with-entry-move-function' and place it in
`org-ref-pdf-directory'. Optional PREFIX argument toggles between
`rename-file' and `copy-file'."
    (interactive "P")
    (save-excursion
      (bibtex-beginning-of-entry)
      (let* ((file (read-file-name "Select file associated with entry: " "~/Downloads"))
             (bibtex-expand-strings t)
             (entry (bibtex-parse-entry t))
             (key (reftex-get-bib-field "=key=" entry))
             (pdf (concat org-ref-pdf-directory (concat key ".pdf")))
             (file-move-func (org-ref-bibtex-get-file-move-func prefix)))
        (if (file-exists-p pdf)
            (message (format "A file named %s already exists" pdf))
          (progn
            (funcall file-move-func file pdf)
            (message (format "Created file %s" pdf))))))))
#+END_SRC
Redefine to also check the file given in the bib entry.
#+BEGIN_SRC emacs-lisp
(after! org-ref
  (defun org-ref-open-bibtex-pdf ()
  "Open pdf for a bibtex entry, if it exists.
assumes point is in
the entry of interest in the bibfile.  but does not check that."
  (interactive)
  (save-excursion
    (bibtex-beginning-of-entry)
    (let* ((bibtex-expand-strings t)
           (entry (bibtex-parse-entry t))
           (key (reftex-get-bib-field "=key=" entry))
           (pdf (funcall org-ref-get-pdf-filename-function key))
           (pdf2 (reftex-get-bib-field "file" entry)))
      (if (file-exists-p pdf)
          (org-open-link-from-string (format "[[file:%s]]" pdf))
        (if (file-exists-p pdf2)
            (org-open-link-from-string (format "[[file:%s]]" pdf2))
          (ding)))))))
#+END_SRC
Use the label names I make, which allows me to access them before export, at the
risk of them not being unique.
#+BEGIN_SRC emacs-lisp
(setq org-latex-prefer-user-labels t)
#+END_SRC
*** Context-dependent Hydra
#+BEGIN_SRC emacs-lisp
(defun gm/context-hydra-launcher ()
  "A launcher for hydras based on the current context."
  (interactive)
  (require 'org-link-edit)
  (if current-prefix-arg
      (hydra-toggle/body)
    (cl-case major-mode
      ('org-mode (let* ((elem (org-element-context))
                        (etype (car elem))
                        (type (org-element-property :type elem)))
                   (cl-case etype
                     (src-block (hydra-babel-helper/body))
                     (link (hydra-org-link-helper/body))
                     ((table-row table-cell) (hydra-org-table-helper/body) )
                     (t (message "No specific hydra for %s/%s" etype type)
                        (hydra-toggle/body)))))
      ('bibtex-mode (org-ref-bibtex-hydra/body))
      (t (message "No hydra for this major mode: %s" major-mode)))))

(bind-key "C-c t" 'gm/context-hydra-launcher)
(after! key-chord
    (key-chord-define-global "jj" 'gm/context-hydra-launcher))
#+END_SRC
**** Links
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(setq hydra-org-link-helper-hint-base
      "
org link helper
_i_ backward slurp     _o_ forward slurp    _n_ next link
_j_ backward barf      _k_ forward barf     _p_ previous link

_q_ quit
")

(defhydra hydra-org-link-helper (:color pink)
  `hydra-org-link-helper-hint-base
  ("i" org-link-edit-backward-slurp)
  ("o" org-link-edit-forward-slurp)
  ("j" org-link-edit-backward-barf)
  ("k" org-link-edit-forward-barf)
  ("n" org-next-link)
  ("p" org-previous-link)
  ("q" nil :color blue))

(setq hydra-org-link-helper/hint
      '(if (equal (org-element-property :path (org-element-context)) "marginnote")
           (prog1
               (let* ((lines (split-string hydra-org-link-helper-hint-base "\n"))
                      (newhint "        _e_ shift margin note")
                      hint)
                 (setf (nth 2 lines) (concat (nth 2 lines) newhint))
                 (setq hint (mapconcat 'identity lines "\n"))
                 (eval
                  (hydra--format nil '(nil nil :hint nil)
                                 hint hydra-org-link-helper/heads)))
             (define-key hydra-org-link-helper/keymap "e"
               (lambda! ()
                        (gm/math-make-marginnote-float)
                        (hydra-org-link-helper/nil))))
         (prog1
             (eval
              (hydra--format nil '(nil nil :hint nil)
                             hydra-org-link-helper-hint-base hydra-org-link-helper/heads))
           (define-key hydra-org-link-helper/keymap "e" nil))))
#+END_SRC
**** Tables
#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-table-helper (:color pink :hint nil)
  "
org table helper
_r_ recalculate     _w_ wrap region      _c_ toggle coordinates
_i_ iterate table   _t_ transpose        _D_ toggle debugger
_B_ iterate buffer  _E_ export table
_e_ eval formula    _s_ sort lines       _d_ edit field

_q_ quit
"
  ("E" org-table-export :color blue)
  ("s" org-table-sort-lines)
  ("d" org-table-edit-field)
  ("e" org-table-eval-formula)
  ("r" org-table-recalculate)
  ("i" org-table-iterate)
  ("B" org-table-iterate-buffer-tables)
  ("w" org-table-wrap-region)
  ("D" org-table-toggle-formula-debugger)
  ("t" org-table-transpose-table-at-point)
  ("c" org-table-toggle-coordinate-overlays :color blue)
  ("q" nil :color blue))
#+END_SRC
**** Source Blocks
#+BEGIN_SRC emacs-lisp
(defun gm/org-babel-src-block-info ()
  (interactive)
  (if (get-buffer-window "*Help*")
      (delete-other-windows)
    (org-babel-view-src-block-info)))

(defhydra hydra-babel-helper (:color pink :hint nil)
  "
org babel src block helper functions
_n_ next       _i_ info           _h_ insert header
_p_ prev       _c_ check
_H_ goto head  _E_ expand
^ ^            _s_ split
_q_ quit       _r_ remove result  _e_ examplify region

"
  ("i" gm/org-babel-toggle-src-block-info)
  ("h" org-babel-insert-header-arg)
  ("c" org-babel-check-src-block :color blue)
  ("s" org-babel-demarcate-block :color blue)
  ("n" org-babel-next-src-block)
  ("p" org-babel-previous-src-block)
  ("E" org-babel-expand-src-block :color blue)
  ("e" org-babel-examplify-region :color blue)
  ("r" org-babel-remove-result :color blue)
  ("H" org-babel-goto-src-block-head)
  ("q" nil :color blue))
#+END_SRC
** Prettifying
*** Headlines
Let's make our headings look a bit nicer. The package =org-bullet-mode= replaces the
asterisks that define an Org heading with pretty symbols, like stylized bullet
points.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(use-package org-superstar
    :commands org-superstar-mode
    :hook (org-mode . org-superstar-mode)
    :config (setq inhibit-compacting-font-caches t))
#+END_SRC
In a similar vein, it helps the visual hierarchy to have text indented in
accordance with the level of the heading, so I always use =org-indent-mode=.
Because it's always active, it's best to diminish it.
#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
(diminish 'org-indent-mode)
#+END_SRC
The dot-dot-dot ellipsis that indicates hidden content can become a bit much
when you have a lot of headlines.
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "⬎")
#+END_SRC
*** Emphasis Markers
It looks much cleaner if we omit emphasis markers such as the =*= asterisks that
make something bold. It is enough to just display the argument as bold.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-hide-emphasis-markers t)
#+END_SRC
*** Lists
Have lists begun by, for example, =-= look like a bullet list.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(font-lock-add-keywords 'org-mode
                        '(("^ *\\([-]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC
This doesn't change anything in the buffer, which is nice.

*** Pretty Symbols in Source Blocks
I do a lot of programming in Org Mode source blocks, and I want to have features
like =prettify-symbols-mode= for =lambda= functions in Elisp. However, this mode is
buffer local, so if I were to turn it on, I would have to display the string
"lambda" as "λ" throughout the buffer, even in paragraphs and the source blocks
of other languages. This is obviously undesirable.

We add hooks to particular languages to activate pretty symbols. In this case I
don't add the lambda fontification, just activate =pretty-symbols-mode=, because
the default variable =lisp-prettify-symbols-mode= already has this pair.
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (setq prettify-symbols-alist
                  '(("lambda" . ?λ)
                    ("lambda!" . (?λ (Br . Bl) ?!))))
            (prettify-symbols-mode)))
#+END_SRC
Then, we modify =org-src-font-lock-fontify-block= (the function that fontifies Org
source blocks) as per [[https://emacs.stackexchange.com/questions/17283/is-it-possible-to-get-prettified-symbols-in-org-mode-source-blocks/17847][this SE post]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun org-src-font-lock-fontify-block (lang start end)
  "Fontify code block.
This function is called by emacs automatic fontification, as long
as `org-src-fontify-natively' is non-nil."
  (let ((lang-mode (org-src--get-lang-mode lang)))
    (when (fboundp lang-mode)
      (let ((string (buffer-substring-no-properties start end))
        (modified (buffer-modified-p)) (org-buffer (current-buffer)) pos next)
    (remove-text-properties start end '(face nil))
    (with-current-buffer
        (get-buffer-create
         (concat " org-src-fontification:" (symbol-name lang-mode)))
      (delete-region (point-min) (point-max))
      (insert string " ") ;; so there's a final property change
      (unless (eq major-mode lang-mode) (funcall lang-mode))
      ;; Avoid `font-lock-ensure', which does not display fonts in
      ;; source block.
      (call-interactively #'font-lock-fontify-buffer)
      (setq pos (point-min))
      (while (setq next (next-single-property-change pos 'face))
        (put-text-property
         (+ start (1- pos)) (1- (+ start next)) 'face
         (get-text-property pos 'face) org-buffer)
        (setq pos next))
      ;; Addition: also copy 'composition info for prettified symbols
      (setq pos (point-min))
      (while (setq next (next-single-property-change pos 'composition))
        (put-text-property
         (+ start (1- pos)) (1- (+ start next)) 'composition
         (get-text-property pos 'composition) org-buffer)
        (setq pos next))
      ;; End addition
      )
    (add-text-properties
     start end
     '(font-lock-fontified t fontified t font-lock-multiline t))
    (set-buffer-modified-p modified)))))
#+END_SRC
*** Inline Remote Images
Add the link type.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "image-url"
 (lambda (path)
   (let ((img (expand-file-name
           (concat (md5 path) "." (file-name-extension path))
           temporary-file-directory)))
     (if (file-exists-p img)
     (find-file img)
       (url-copy-file path img)
       (find-file img)))))
#+END_SRC
And the function to activate inlining.
#+BEGIN_SRC emacs-lisp
(defun image-url-overlays ()
  "Put image overlays on remote image urls."
  (interactive)
  (cl-loop for image-url in (org-element-map (org-element-parse-buffer) 'link
               (lambda (link)
                 (when (string= "image-url" (org-element-property :type link))
                   link)))
    do
    (let* ((path (org-element-property :path image-url))
           (ov (make-overlay (org-element-property :begin image-url)
                 (org-element-property :end image-url)))
           (img (create-image (expand-file-name
                   (concat (md5 path)
                       "."
                       (file-name-extension
                        path))
                   temporary-file-directory))))
      (overlay-put ov 'display img)
      (overlay-put ov 'image-url t))))

(defun image-url-clear-overlays ()
  "Reove overlays on image-urls."
  (interactive)
  (require 'ov)
  (ov-clear 'image-url))
#+END_SRC
** Babel
Set up languages loaded for use in Org source blocks and their respective
default execution commands.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(org-babel-do-load-languages
      'org-babel-load-languages '((python . t)
                                  (latex . t)
                                  (shell . t)))

(setq org-babel-python-command "python3.8"
      org-babel-latex-command "pdflatex"
      org-babel-sh-command "sh")
#+END_SRC
Make Org Mode source blocks act normally with respect to indentation and syntax
highlighting.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-edit-src-content-indentation 0)
#+END_SRC
I'm generally fine with just evaluating a code block.
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC
*** Proper Keymaps in Org Source Blocks
[[http://kitchingroup.cheme.cmu.edu/blog/2017/06/10/Adding-keymaps-to-src-blocks-via-org-font-lock-hook/][John Kitchin]] explains how to get use keybindings from the appropriate language
major mode inside Org source blocks. This heavily reduces the need to activate
special edit mode with =C-c '=. The idea is that we set up keymaps and apply them
with font-lock by hooking into Org Mode's font-lock. We define the function that
applies the keymap to each block.
#+BEGIN_SRC emacs-lisp
(defun gm/add-keymap-to-src-blocks (limit)
  "Add keymaps to src-blocks defined in `gm/src-block-keymaps'."
  (let ((case-fold-search t))
    (while (re-search-forward org-babel-src-block-regexp limit t)
      (let ((lang (match-string 2))
            (beg (match-beginning 0))
            (end (match-end 0)))
        (if (assoc (org-no-properties lang) gm/src-block-keymaps)
            (progn
              (add-text-properties
               beg end `(local-map ,(cdr (assoc
                                          (org-no-properties lang)
                                          gm/src-block-keymaps))))))))))
#+END_SRC
To be able to toggle this, we add a minor mode. This is where we add the
relevant hook.
#+BEGIN_SRC emacs-lisp
(define-minor-mode gm/src-keymap-mode
  "Minor mode to add mode keymaps to src-blocks."
  :init-value nil
  (if gm/src-keymap-mode
      (progn
        (require 'elpy)
        (add-hook 'org-font-lock-hook #'gm/add-keymap-to-src-blocks t)
        (add-to-list 'font-lock-extra-managed-props 'local-map))
    (remove-hook 'org-font-lock-hook #'gm/add-keymap-to-src-blocks)
    (cursor-sensor-mode -1))
  (call-interactively #'font-lock-fontify-buffer))
#+END_SRC
Here are the actual maps.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defvar gm/src-block-keymaps
      `(("python" . ,(let ((map (make-composed-keymap
                                 `(,(when (boundp 'elpy-mode)
                                      elpy-mode-map)
                                   ,(when (boundp 'python-mode)
                                      python-mode-map))
                                 org-mode-map)))
                       ;; In org-mode I define RET so we redefine
                       (define-key map (kbd "RET") 'newline-and-indent)
                       (define-key map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
                       map))
        ("emacs-lisp" . ,(let ((map (make-composed-keymap
                                     `(,emacs-lisp-mode-map)
                                     org-mode-map)))
                           (define-key map (kbd "RET") 'newline-and-indent)
                           (define-key map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
                           map))))
#+END_SRC
** LaTeX
Highlight LateX inline math in org mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-highlight-latex-and-related '(latex))
#+END_SRC
*** Math Mode
Define a keychord to enter inline math mode. This allows me to get around
messing with making =$= an electrically paired delimiter.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(after! key-chord
  (key-chord-define org-mode-map "r4" #'gm/create-or-exit-math-fragment)
  (key-chord-define org-mode-map "df" #'gm/create-or-exit-math-fragment))
#+END_SRC
**** Pretty Math Symbols
I got the source for this from [[https://bitbucket.org/mortiferus/latex-pretty-symbols.el][mortiferus]]. The file I use is not the one from
their Bitbucket repo; I have, for example, removed subscripts and superscripts.
#+BEGIN_SRC emacs-lisp
(require 'gm-pretty-math)
#+END_SRC
*** Don't Break Paragraph on Comments'
[[https://emacs.stackexchange.com/questions/22574/orgmode-export-how-to-prevent-a-new-line-for-comment-lines][John Kitchin]] tells us how to remove comments from an Org document when exporting
to LaTeX.
#+BEGIN_SRC emacs-lisp
(defun delete-org-comments (backend)
  (cl-loop for comment in (reverse (org-element-map (org-element-parse-buffer)
                                    'comment 'identity))
        do (setf (buffer-substring (org-element-property :begin comment)
                                (org-element-property :end comment))
              "")))
(add-hook 'org-export-before-processing-hook 'delete-org-comments)
#+END_SRC
*** Reformat Math Fragment
For my primary use case of typing math in LaTeX, I don't care about how the
source looks when I'm typing it; I'm often typing it live, so the main concern
is speed. But later, I want it to look nice and readable, with spacing and so
on.

The idea is pretty simple. We just maintain a list of regexps in
=gm/reformat-fragment-alist= and run them all on a given LaTeX fragment with
=gm/reformat-fragment=. The main thing to notice is that the regexp that takes
care of too many spaces goes last. This way, we don't have to worry about
introducing too many spaces in the earlier regexps.
#+BEGIN_SRC emacs-lisp
(defcustom gm/reformat-fragment-alist
  '(("+" " + " "spaces around +")
    ("\\( \\|{}\\)*\\([_^]\\)[ ]*" "\\2" "remove spaces and braces around ^ and _")
    (" +" " " "no more than 1 space in a row")
    ("\\(\\\\(\\) " "\\1" "no space at start of fragment")
    (" \\(\\\\)\\)" "\\1" "no space at end of fragment"))
  "Alist of (REGEXP TO DOCSTRING) parsed by `gm/reformat-fragment'.
Upon reformatting, each REGEXP is replaced with TO. DOCSTRING
simply explains what the regexp does."
  :type 'alist
  :group 'quick-math)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun gm/reformat-fragment (&optional fr)
  (let ((fr-type (car (if fr fr (org-element-context))))
        (fr-begin (if fr
                      (nth 1 fr)
                    (org-element-property :begin (org-element-context))))
        fr-end base)
    (goto-char fr-begin)
    (setq fr-end (- (org-element-property :end (org-element-context))
                    (org-element-property :post-blank (org-element-context))))
    (setq base (buffer-substring-no-properties fr-begin fr-end))
    (dolist (reg gm/reformat-fragment-alist)
      (setq base (replace-regexp-in-string (car reg) (nth 1 reg) base)))
    (delete-region fr-begin fr-end)
    (insert base)
    (when (and (eq fr-type 'latex-environment)
               (eq (char-before) (string-to-char "}")))
      (newline))))
#+END_SRC
*** Equation Auto Preview
:PROPERTIES:
:ORDERED:  t
:END:
Use =imagemagick=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-preview-latex-default-process 'imagemagick)
#+END_SRC
Not too small.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(when gm/user (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.75)))
#+END_SRC
Where should it be? Let's put them all in the same place, so that common
fragments (like =x^2=) are never generated more than once and so that we don't
litter our folders.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-preview-latex-image-directory
      (expand-file-name "cache/ltximg/" user-emacs-directory))
#+END_SRC
Inspired by John Kitchin. I've modified it to be toggleable and to run a hook on
leaving a math fragment.
#+BEGIN_SRC emacs-lisp
(require 'ov)
(defvar gm/org-last-fragment nil
  "Holds the type and position of last valid fragment we were on.
  Format: (FRAGMENT_TYPE FRAGMENT_POINT_BEGIN)")

(defvar gm/org-valid-fragment-type '(latex-fragment latex-environment)
  "List of types of fragments that will be previewed by `gm/org-preview-fragment'")

(defun gm/org-curr-fragment (&optional location)
  "Returns the type and position of the current fragment available
for preview inside org-mode. Returns nil at non-displayable fragments."
  (let* ((loc (if location location (point)))
         (fr (if (not (eq loc (point)))
                 (save-excursion
                   (goto-char loc)
                   (org-element-context))
               (org-element-context)))
         (fr-type (car fr)))
    (when (memq fr-type gm/org-valid-fragment-type)
      ;; \(...\)| cursor there should not result in active fragment
      (let ( ; we only define these things now to optimize
            (fr-begin (org-element-property :begin fr))
            (fr-end (org-element-property :end fr))
            ;; add one for the space after in \end{equation}
            (fr-post-blank (1+ (org-element-property :post-blank fr))))
        (when
            ;; gotta fix some weird behaviour with environments
            ;; make sure that if you're on the line after
            ;; \end{equation}, you're considered out of the fragment
            ;; check if point is between the actual end of the
            ;; LaTex environment and the "supposed end" extended by blank ;; lines after the environment
            (and
             (> loc fr-begin)
             (<= loc (- fr-end fr-post-blank)))
          (list fr-type fr-begin))))))

(defun gm/org-remove-fragment-overlay (fr)
  "Remove fragment overlay at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (goto-char fr-begin)
    (when (memq fr-type gm/org-valid-fragment-type)
      (let ((ov (car (--filter
                      (and
                       (<= (overlay-start it) (point))
                       (>= (overlay-end it) (point)))
                      (org--list-latex-overlays)))))
        (when ov
          (delete-overlay ov))))))

(defun gm/org-preview-fragment (fr)
  "Preview org fragment at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (when (memq fr-type gm/org-valid-fragment-type)
      (goto-char fr-begin)
      (org-toggle-latex-fragment))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun gm/org-auto-toggle-fragment-display ()
  "Automatically toggle a displayable org mode fragment."
  (and (eq 'org-mode major-mode)
       (let ((curr (gm/org-curr-fragment))
             (next (gm/org-curr-fragment (1+ (point)))))
         (cond
          ((and (not curr) next)
           (gm/org-remove-fragment-overlay next)
           (setq gm/org-last-fragment next))
          ;; were on a fragment and now on a new fragment
          ((and
            ;; fragment we were on
            gm/org-last-fragment
            ;; and are on a fragment now
            curr
            ;; but not on the last one this is a little tricky. as you edit the
            ;; fragment, it is not equal to the last one. We use the begin
            ;; property which is less likely to change for the comparison.
            (not (equal curr gm/org-last-fragment)))
           ;; go back to last one and put image back, provided there is still a fragment there
           (save-excursion
             (gm/org-preview-fragment gm/org-last-fragment)
             ;; now remove current image
             (gm/org-remove-fragment-overlay curr))

           ;; and save new fragment
           (setq gm/org-last-fragment curr))

          ;; were on a fragment and now are not on a fragment
          ((and
            ;; not on a fragment now
            (not curr)
            ;; but we were on one
            gm/org-last-fragment)

           ;; put image back on, provided that there is still a fragment here.
           (save-excursion
             (gm/org-preview-fragment gm/org-last-fragment))
           ;; unset last fragment
           (setq gm/org-last-fragment nil))

          ;; were not on a fragment, and now are
          ((and
            ;; we were not one one
            (not gm/org-last-fragment)
            ;; but now we are
            curr)
           ;; remove image
           (save-excursion
             (gm/org-remove-fragment-overlay curr)
             (setq gm/org-last-fragment curr))
           ;; there is no point being in on the \( or \) part of the math fragment
           ;; this code jumps the point into the actual math part of the fragment
           (when (and (eq (char-before) 92)
                       (eq (char-after) 41))
                  (backward-char 1)))
          ;; for the forward char, we have to do things a little
          ;; differently, because the point is already in the fragment
          ((and curr
                gm/org-last-fragment
                (eq (char-before) 92)
                (eq (char-after) 40)
                (eq last-command 'forward-char))
           (forward-char 1))))))
#+END_SRC
We can also centre equations and (this is useful when equation preview mode is
disabled) add a tooltip to them that lets you edit the equation when you click
on it. This is more John Kitchin code.
#+BEGIN_SRC emacs-lisp
(defun gm/org-justify-fragment-overlay (beg end image imagetype)
  "Adjust the justification of a LaTeX fragment.
The justification is set by :justify in
`org-format-latex-options'. Only equations at the beginning of a
line are justified."
  (when
   ;; Centered justification
   (and (= beg (line-beginning-position))
         (string= "\\begin"
                  (buffer-substring-no-properties
                   beg (+ beg 6))))
    (let* ((img (create-image image 'png t))
           (width (car (image-size img)))
           (offset (floor (- (/ (min (window-max-chars-per-line) fill-column) 3) (/ width 3)))))
      (overlay-put (ov-at) 'before-string (make-string offset ? )))))

(defun gm/org-latex-fragment-tooltip (beg end image imagetype)
  "Add the fragment tooltip to the overlay and set click function to toggle it."
  (overlay-put (ov-at) 'help-echo
               (concat (buffer-substring beg end)
                       "\nmouse-1 to toggle."))
  (overlay-put (ov-at) 'local-map (let ((map (make-sparse-keymap)))
                                    (define-key map [mouse-1]
                                      `())
                                    map)))

(advice-add 'org--format-latex-make-overlay :after 'gm/org-justify-fragment-overlay)
(advice-add 'org--format-latex-make-overlay :after 'gm/org-latex-fragment-tooltip)
#+END_SRC
Create a minor mode to preview equations. The keybinding is in [[*Toggles][a hydra]].
#+BEGIN_SRC emacs-lisp
(define-minor-mode gm/eq-preview-mode
  "Preview equations."
  :init-value nil)

(defun gm/eq-toggle ()
  (if gm/eq-preview-mode
      (progn
        (add-hook 'post-command-hook 'gm/org-auto-toggle-fragment-display t 'local))
    (remove-hook 'post-command-hook 'gm/org-auto-toggle-fragment-display 'local)))

(add-hook 'gm/eq-preview-mode-hook #'gm/eq-toggle)
#+END_SRC
*** Change Bracket Sizes
This allows the user to easily change the size of brackets in LaTeX expressions.
#+BEGIN_SRC emacs-lisp
(autoload 'bratex-config "bratex")
(add-hook 'quick-math-mode-hook #'bratex-config)
#+END_SRC
*** Allow Alphabetical List
#+BEGIN_SRC emacs-lisp
(setq org-list-allow-alphabetical t)
#+END_SRC
*** Export
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name "tufte-org-mode/" gmacs-custom-dir))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun gm/org-latex-export ()
  (interactive)
  (require 'ox-tufte-latex)
  (save-excursion
    (while (and (not (org-entry-get (point) "EXPORT_FILE_NAME"))
                (not (string= (buffer-substring-no-properties
                               (line-beginning-position)
                               (min (point-max) (+ 2 (line-beginning-position))))
                              "* ")))
      (outline-up-heading 1 t))
    (when-let ((filebase (org-entry-get (point) "EXPORT_FILE_NAME")))
      (let* ((class (org-entry-get (point) "EXPORT_LATEX_CLASS"))
             (cmd (org-entry-get (point) "EXPORT_LATEX_CMD"))
             (file (replace-regexp-in-string "\\(\\.[^\\.]+\\)*$" ".tex" filebase))
             (processname (format "latex-export-%s" file)))
        (if (and class
                 (not (string= class "gm-notes")))
            (org-latex-export-to-latex nil t)
          (org-tufte-latex-export-to-latex nil t))
        (when (get-process processname)
          (kill-buffer (process-buffer processname)))
        (async-start-process processname
                             "latexmk"
                             (lambda (file) (message (format "Exported %s" file)))
                             (if (string= cmd "PDF") "-pdf" "-xelatex")
                             "-interaction=nonstopmode"
                             file)
        ;; (async-start-process "latex-cleanup"
        ;;                      "latexmk"
        ;;                      nil
        ;;                      "-xelatex"
        ;;                      "-c")
        ))))
#+END_SRC
Bind this in Org mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c b" . gm/org-latex-export)
#+END_SRC
Don't use straight quotes when exporting.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-export-with-smart-quotes t)
#+END_SRC
**** Math Macros
I have a LaTeX =.sty= file with macros for math. I want this to be automatically
included in every LaTeX file exported from Org Mode. The optional third argument
makes sure this package is also loaded when compiling LaTeX image previews, such
as equation previews.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(when gm/user
  (setq org-latex-packages-alist
      '(("" "gm-math" t))))
#+END_SRC
**** Latexmk
The command =gm/auto-tex-cmd= looks at your Org file. If it finds that =xelatex= has
been specified as the desired compilation command, then it uses that. Otherwise,
it runs =latexmk= with normal =pdflatex=. We don't need to worry about compiling the
correct number of times to include bibliography information, or to render
graphics correctly; =latexmk= handles all of that.
#+BEGIN_SRC emacs-lisp
(defun gm/auto-tex-cmd ()
  (let ((texcmd))
    (setq texcmd "latexmk -pdf -quiet %f")
    (if (string-match "LATEX_CMD: xelatex" (buffer-string))
        (setq texcmd "latexmk -xelatex -pdf -quiet %f"))
    (setq org-latex-pdf-process (list texcmd))))

(add-hook 'org-mode-hook 'gm/auto-tex-cmd)
#+END_SRC
**** Command Links
:PROPERTIES:
:header-args: :tangle no :noweb-ref org-settings :results silent
:END:
No option.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (format "\\%s{%s}" path desc))))
#+END_SRC
One option.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex-opt"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (let* ((desc-list (split-string desc ";"))
                    (opt (nth 1 desc-list))
                    (arg (nth 0 desc-list)))
               (format "\\%s%s{%s}" path
                       (if (equal "" opt) opt (format "[%s]" opt))
                       arg)))))
#+END_SRC
One option, which goes afterwards.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex-opt-after"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (let* ((desc-list (split-string desc ";"))
                    (opt (nth 1 desc-list))
                    (arg (nth 0 desc-list)))
               (format "\\%s{%s}%s" path arg
                       (if (equal "" opt) opt (format "[%s]" opt)))))))
#+END_SRC
Todo link.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "todo"
 :follow nil
 :face '(:foreground "red" :underline t)
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (format "\\marginnote{\\textcolor{red}{\\textbf{TODO:}} %s}" path))))
#+END_SRC
Correction link.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "corr"
 :follow nil
 :face '(:foreground "green" :underline t)
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (format "\\textcolor{SeaGreen}{%s}" path))))
#+END_SRC
By default, Org Mode exports references to LaTeX with =\ref=. I prefer using the
=cleveref= package, which uses the =\cref= macro.
#+BEGIN_SRC emacs-lisp
(after! org-ref
  (org-link-set-parameters "ref"
                           :export
                           (lambda (label desc format)
                             (format "\\cref{%s}" label))))
#+END_SRC
**** Export Classes
#+BEGIN_SRC emacs-lisp
(after! ox-latex
  (add-to-list 'org-latex-classes
               '("tufte-handout"
                 "\\documentclass{tufte-handout}
   [NO-DEFAULT-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")))

  (add-to-list 'org-latex-classes
               '("assignment"
                 "\\documentclass[12pt]{article}
\\usepackage{uts-assignment}
\\renewcommand{\\maketitle}{}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

  (add-to-list 'org-latex-classes
               '("gm-mla"
                 "\\documentclass[12pt]{article}
\\usepackage{uts-mla}
\\renewcommand{\\maketitle}{}
\\renewcommand{\\tableofcontents}{}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubection*{%s}")))

  (add-to-list 'org-latex-classes
               '("gm-notes"
                 "\\documentclass{gm-notes}
[NO-DEFAULT-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+END_SRC
We make =gm-notes= our default class.
#+BEGIN_SRC emacs-lisp
(when gm/user (setq org-latex-default-class "gm-notes"))
#+END_SRC
* Media
Here I configure everything for recreation and contact with the outside world:
managing email, consuming published media (blog posts and YouTube videos), and
listening to music.
** Mail
I used to use =mu4e=, but now I use =notmuch=. It has greater synergy with =elfeed=,
my RSS reader (in fact, =elfeed= was inspired by =notmuch=). Also, I found that =mu4e=
was too complicated and tried to do too much. As the name suggests, =notmuch=
doesn't have much. It's simple, transparent, and it works. That makes it perfect
for me.
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package notmuch
  :commands (notmuch notmuch-refresh-all-buffers)
  :config
  (require 'smtpmail)
  (require 'smtpmail-async)
  <<notmuch-settings>>
  :custom
  (nms-settings-file (expand-file-name "network-security.data" gmacs-cache-dir))
  :bind (:map notmuch-common-keymap
              ("g" . notmuch-refresh-this-buffer)
              ("G" . notmuch-refresh-all-buffers)
         :map notmuch-show-mode-map
              ("o" . ace-link-addr)))
#+END_SRC
Set up the mail directory and draft location.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq message-directory "~/mail/uni"
      message-auto-save-directory "~/mail/Uni/Drafts"
      notmuch-fcc-dirs '((".*" . "\"uni/Sent Items\" +sent -inbox -unread")))
#+END_SRC
Provide my email and name.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(when gm/user
  (setq mail-user-agent 'message-user-agent
        user-mail-address gm--email
        user-full-name "Gautam Manohar"))
#+END_SRC
SMTP for sending mail. The =stream-type= is important because I want my outgoing
mail to at least use TLS encryption. One day, though, I would like to adopt a
more rigorous system of encryption.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq send-mail-function #'async-smtpmail-send-it
      message-send-mail-function #'async-smtpmail-send-it
      smtpmail-debug-info t
      smtpmail-debug-verb t
      smtpmail-stream-type 'starttls
      smtpmail-smtp-server gm--send-mail-server
      smtpmail-smtp-service 587)
#+END_SRC
Some commonly used searches.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq notmuch-saved-searches
      '((:name "inbox" :query "tag:inbox" :key "i" :sort-order oldest-first)
        (:name "flagged" :query "tag:flagged" :key "f")
        (:name "sent" :query "tag:sent" :key "s" :sort-order newest-first)
        (:name "drafts" :query "tag:draft" :key "d")))
#+END_SRC
Show newest mail first.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq notmuch-search-oldest-first nil)
#+END_SRC
Nice stuff to have for sending mail.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq message-kill-buffer-on-exit t
      notmuch-address-command 'internal)
#+END_SRC
Most modern mail clients expect mail to be soft-wrapped. That is, the paragraph
conforms to the width of the viewer the person reading the mail is using, not to
the sender's preference of 80 characters or whatever it may be. However, when
sending mail, I still want the buffer to look as if it was hard-wrapped. Enter
=visual-fill-column-mode=. This mode works with =visual-line-mode= to wrap the
paragraph not at the window edge but at =fill-column=.
#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :commands visual-fill-column-mode
  :hook (notmuch-message-mode . visual-fill-column-mode)
  :init
  (add-hook 'notmuch-message-mode-hook 'turn-off-auto-fill)
  (add-hook 'notmuch-show-mode-hook 'turn-off-auto-fill)
  :config (advice-add 'text-scale-adjust :after
                      #'visual-fill-column-adjust))
#+END_SRC
On a similar note, I don't want filling the paragraph to do anything, unless I
really do.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(defun gm/maybe-fill-paragraph ()
  (interactive)
  (when current-prefix-arg
      (fill-paragraph)))

(bind-key "M-q" #'gm/maybe-fill-paragraph notmuch-message-mode-map)
#+END_SRC
I don't want to manually do this.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(advice-add #'notmuch-show-reply-sender :after (lambda! () (open-line 1)))
#+END_SRC
Accessing mail. When we first open up =notmuch=, I want to start a system script
that checks for new mail periodically.
#+BEGIN_SRC emacs-lisp
(defun gm/open-mail ()
  (interactive)
  (notmuch)
  (notmuch-refresh-this-buffer))

(bind-key "C-c m" #'gm/open-mail)
#+END_SRC
*** Hard Delete Mail
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(defun gm/notmuch-delete-mail ()
  (interactive)
  (notmuch-search-tag (list "+deleted"))
  (call-process-shell-command
   "notmuch search --output=files --format=text0 tag:deleted | xargs -0 rm && notmuch new"
   nil nil nil)
  (notmuch-search-refresh-view))

(bind-key "D" #'gm/notmuch-delete-mail notmuch-search-mode-map)
#+END_SRC
*** See Last Unread in Thread
Notmuch doesn't take you to the latest unread message in a thread. Usually, you
can work around this by going to the end of the buffer, but this doesn't work if
the thread is non-linear and the message of interest is somewhere in the middle.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(defun gm/next-unread ()
  (interactive)
  (let ((init (point)))
    (catch 'break
      (while t
        (when (member "unread" (notmuch-show-get-tags))
          (let ((props (notmuch-show-get-message-properties)))
            (notmuch-show-message-visible props t)
            (notmuch-show-mark-read)
            (throw 'break t)))
        (when (not (notmuch-show-goto-message-next))
          (message "No more unread messages.")
          (goto-char init)
          (throw 'break t))))))

(bind-key "U" #'gm/next-unread notmuch-show-mode-map)
#+END_SRC
*** Send HTML Mail
This code from [[http://kitchingroup.cheme.cmu.edu/blog/category/orgmode/4/][John Kitchin]] lets you write mail in Org Mode and send it
formatted as HTML. This is incredibly powerful, because you can include syntax
highlighted code, LaTeX math images, and even the image output of Babel blocks,
all composed in plain text with Org Mode. Unfortunately, when I first set up
this process, I received an error when trying to send HTML mail with LaTeX math
in it (the desired =.png= was not produced and I had to adjust =imagemagick= as
apart of =org-preview-latex-process-alist=). Investigating the =.log= files showed
that the issue was not with =pdflatex= (and indeed a proper PDF was
produced). In fact, the issue was with ImageMagick, which did not have the
proper permissions to do its job on PDF files. Here's the fix:

Find =/etc/ImageMagick-7/policy.xml=. Change
#+BEGIN_SRC html :tangle no
<policy domain="coder" rights="none" pattern="PDF" />
#+END_SRC
to
#+BEGIN_SRC html :tangle no
<policy domain="coder" rights="read|write" pattern="PDF" />
#+END_SRC
Looking at the =rights= field makes it clear that the permissions were off.

Now for the Emacs setup. This library converts Org into HTML.
#+BEGIN_SRC emacs-lisp
(autoload 'org-mime-htmlize "org-mime")
#+END_SRC
Then we give ourselves a way to activate Org Mode mail.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(defun gm/compose-html-org ()
  (interactive)
  (setq *compose-html-org* t)
  (org-mode)
  (quick-math-mode)
  (auto-fill-mode -1))

(bind-key "M-m" #'gm/compose-html-org notmuch-message-mode-map)
#+END_SRC
Let's define a function to send the mail.
#+BEGIN_SRC emacs-lisp
(defun gm/org-htmlize-and-send ()
  "When composing an Org HTML message, htmlize and send it."
  (interactive)
  (when (and (not (org-in-src-block-p))
             (bound-and-true-p *compose-html-org*))
    (setq *compose-html-org* nil)
    (notmuch-message-mode)
    (org-mime-htmlize)
    (notmuch-mua-send-and-exit)))

(add-hook 'org-ctrl-c-ctrl-c-hook 'gm/org-htmlize-and-send t)
#+END_SRC
If we're sending HTML, we might as well make it pretty. Let's nicely offset
block quotes.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mime-html-hook
          (lambda ()
            (org-mime-change-element-style
             "blockquote" "border-left: 2px solid gray; padding-left: 4px;")))
#+END_SRC
We definitely don't want to export the table of contents or section numbers.
It's an email, not an essay.
#+BEGIN_SRC emacs-lisp
(setq org-mime-export-options '(:section-numbers nil
                                :with-author nil
                                :with-toc nil))
#+END_SRC
*** Don't Forget Attachments
From [[https://gitlab.com/ambrevar/dotfiles/blob/master/.emacs.d/lisp/patch-notmuch.el][ambrevar's dotfiles]].
#+BEGIN_SRC emacs-lisp
(defcustom notmuch-message-attach-regex
  "\\b\\(attache\?ment\\|attached\\|attach\\|pi[èe]ce\s+jointe?\\)\\b"
  "Pattern of text announcing there should be an attachment.

This is used by `notmuch-message-check-attach' to check email
bodies for words that might indicate the email should have an
attachement. If the pattern matches and there is no attachment (a
`<#part ...>' magic block), notmuch will show a confirmation
prompt before sending the email.

The default regular expression is deliberately liberal: we prefer
false positive than forgotten attachments. This should be
customized for non-english languages and notmuch welcomes
additions to the pattern for your native language, unless it
conflicts with common words in other languages."
  :type '(regexp)
  :group 'notmuch-send)

(defun notmuch-message-check-attach ()
  """Check for missing attachments.

This is normally added to `message-send-hook' and is configured
through `notmuch-message-attach-regex'."""
  (save-excursion ;; XXX: this fails somehow: point is at the end of the buffer on error
    (goto-char (point-min))
    (if (re-search-forward notmuch-message-attach-regex nil t)
        (progn
          (goto-char (point-min))
          (unless (re-search-forward "<#part [^>]*filename=[^>]*>" nil t)
            (or (y-or-n-p "Email seems to refer to attachment, but nothing attached, send anyways?")
                (error "No attachment found, aborting")))))))

(add-hook 'message-send-hook #'notmuch-message-check-attach)
#+END_SRC
*** Unsubscribe
#+BEGIN_SRC emacs-lisp
(defun gm/notmuch-show-unsubscribe ()
   "When in a notmuch show mail, try to find an unsubscribe link and
click it. This will be the link nearest the end of the message which
either contains or follows the word unsubscribe."
(interactive)
(notmuch-show-move-to-message-bottom)
(when (search-backward "unsubscribe" (notmuch-show-message-top))
  (if (ffap-url-at-point)
      (goto-char (car ffap-string-at-point-region)))
  (ffap-next-url)))
#+END_SRC
*** Better Hello Screen
From [[http://www.holgerschurig.de/en/emacs-notmuch-hello/][Holger Schurig]].
#+BEGIN_SRC emacs-lisp
(setq notmuch-hello-sections '())
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun my-notmuch-hello-insert-recent-searches ()
  "Insert recent searches."
  (when notmuch-search-history
    (widget-insert "Recent searches:")
    (widget-insert "\n\n")
    (let ((start (point)))
      (cl-loop for i from 1 to notmuch-hello-recent-searches-max
        for search in notmuch-search-history do
        (let ((widget-symbol (intern (format "notmuch-hello-search-%d" i))))
          (set widget-symbol
           (widget-create 'editable-field
                  ;; Don't let the search boxes be
                  ;; less than 8 characters wide.
                  :size (max 8
                         (- (window-width)
                        ;; Leave some space
                        ;; at the start and
                        ;; end of the
                        ;; boxes.
                        (* 2 notmuch-hello-indent)
                        ;; 1 for the space
                        ;; before the `[del]'
                        ;; button. 5 for the
                        ;; `[del]' button.
                        1 5))
                  :action (lambda (widget &rest ignore)
                        (notmuch-hello-search (widget-value widget)))
                  search))
          (widget-insert " ")
          (widget-create 'push-button
                 :notify (lambda (widget &rest ignore)
                       (when (y-or-n-p "Are you sure you want to delete this search? ")
                     (notmuch-hello-delete-search-from-history widget)))
                 :notmuch-saved-search-widget widget-symbol
                 "del"))
        (widget-insert "\n"))
      (indent-rigidly start (point) notmuch-hello-indent))
    nil))

(add-to-list 'notmuch-hello-sections #'my-notmuch-hello-insert-recent-searches)
(add-to-list 'notmuch-hello-sections #'notmuch-hello-insert-search)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defface my-notmuch-hello-header-face
  '((t :weight bold))
  "Font for the header in `my-notmuch-hello-insert-searches`."
  :group 'notmuch-faces)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun my-count-query (query)
  (with-temp-buffer
    (insert query "\n")
    (call-process-region (point-min) (point-max) notmuch-command t t nil "count" "--batch")
    (goto-char (point-min))
    (let ((n (read (current-buffer))))
      (if (= n 0)
          nil
        (notmuch-hello-nice-number n)))))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun my-notmuch-hello-query-insert (cnt query elem)
  (if cnt
      (let* ((str (format "%s" cnt))
             (widget-push-button-prefix "")
             (widget-push-button-suffix "")
             (oldest-first (case (plist-get elem :sort-order)
                             (newest-first nil)
                             (oldest-first t)
                             (otherwise notmuch-search-oldest-first))))
        (widget-create 'push-button
                       :notify #'notmuch-hello-widget-search
                       :notmuch-search-terms query
                       :notmuch-search-oldest-first oldest-first
                       :notmuch-search-type 'tree
                       str)
        (widget-insert (make-string (- 8 (length str)) ? )))
    (widget-insert "        ")))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun my-notmuch-hello-insert-searches ()
  "Insert the saved-searches section."
  (widget-insert (propertize "New     Total      Key  List\n" 'face 'my-notmuch-hello-header-face))
  (mapc (lambda (elem)
          (when elem
            (let* ((q_tot (plist-get elem :query))
                   (q_new (concat q_tot " AND tag:unread"))
                   (n_tot (my-count-query q_tot))
                   (n_new (my-count-query q_new)))
              (my-notmuch-hello-query-insert n_new q_new elem)
              (my-notmuch-hello-query-insert n_tot q_tot elem)
              (widget-insert "   ")
              (widget-insert (plist-get elem :key))
              (widget-insert "    ")
              (widget-insert (plist-get elem :name))
              (widget-insert "\n"))))
        notmuch-saved-searches))
(add-to-list 'notmuch-hello-sections #'my-notmuch-hello-insert-searches)
#+END_SRC
** Elfeed
Elfeed is a feed manager for Emacs. It lets me manage YouTube subscriptions and
other forms of media, such as blogs. I plan to also use it for academic articles
when the need arises. Many of the snippets (tagged =bjm/=) I use here was written
by the author of [[http://pragmaticemacs.com][Pragmatic Emacs]].
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package elfeed
  :commands (elfeed elfeed-db-load))
(setq elfeed-db-directory "~/.emacs.d/.elfeed")
(after! elfeed
  (bind-keys :map elfeed-search-mode-map
             ("q" . bjm/elfeed-save-db-and-bury)
             ("f" . gm/elfeed-hydra/body)
             ("*" . gm/elfeed-toggle-star)
             ("u" . gm/elfeed-toggle-unread)
             ([remap elfeed-search-live-filter]
              . bjm/elfeed-search-live-filter-space))
  <<elfeed-settings>>)
#+END_SRC
By default, =elfeed= stores the feeds it should compile in an elisp file. But Org
is easier.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-settings
(autoload 'elfeed-org "elfeed-org")
(elfeed-org)
(setq rmh-elfeed-org-files
      `(,(expand-file-name "elfeed.org" org-directory)))
#+END_SRC
*** Launching
We want to make sure =elfeed= reads from the disk before it launches. This makes
our =.elfeed= easier to synchronize across machines.
#+BEGIN_SRC emacs-lisp
(defun bjm/elfeed-load-db-and-open ()
  "Wrapper to load the elfeed db from disk before opening"
  (interactive)
  (elfeed-db-load)
  (elfeed)
  (elfeed-search-update--force))

(defun bjm/elfeed-save-db-and-bury ()
  "Wrapper to save the elfeed db to disk before burying buffer"
  (interactive)
  (elfeed-db-save)
  (quit-window))

(bind-key "C-c e" #'bjm/elfeed-load-db-and-open)
(bind-key "C-c C-e" #'bjm/elfeed-load-db-and-open)
#+END_SRC
*** Improvements
Take out junk entries.
#+BEGIN_SRC emacs-lisp
(setq-default elfeed-search-filter "@6-months-ago +unread -junk")
#+END_SRC
It's nice to have a way to star content for future reference.
#+BEGIN_SRC emacs-lisp
(defun gm/elfeed-toggle-star ()
  (interactive)
  (elfeed-search-toggle-all 'starred))
#+END_SRC
Then we add a visual indicator.
#+BEGIN_SRC emacs-lisp
(defface elfeed-search-starred-title-face
  '((t :foreground "#f77"))
  "Marks a starred Elfeed entry."
  :group 'basic-faces)
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-settings
(push '(starred elfeed-search-starred-title-face) elfeed-search-face-alist)
#+END_SRC
[[http://pragmaticemacs.com/emacs/a-tweak-to-elfeed-filtering/][Life is too short to type extra spaces.]]
#+BEGIN_SRC emacs-lisp
(defun bjm/elfeed-search-live-filter-space ()
  "Insert space when running elfeed filter"
  (interactive)
  (let ((elfeed-search-filter (concat elfeed-search-filter " ")))
    (elfeed-search-live-filter)))
#+END_SRC
Add thumbnails (from [[https://www.reddit.com/r/emacs/comments/ao2oud/how_to_add_more_data_to_elfeed_about_youtube/][Reddit]]).
#+BEGIN_SRC emacs-lisp
(defvar gm/yt-regexp "youtu\\.?be")

(defun youtube-url-p (url)
  (string-match url gm/yt-regexp))

(defun youtube-get-thumbnail (_ xml entry)
  (when (youtube-url-p (elfeed-entry-link entry))
    (setf (elfeed-meta entry :my/thumbnail)
          (xml-query '(group thumbnail :url) xml))))

(add-hook 'elfeed-new-entry-parse-hook #'youtube-get-thumbnail)
#+END_SRC
*** Consuming Media
We refresh the feed every ten minutes, starting ten seconds after Emacs opens.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-settings
(run-with-timer 10 (* 60 30) 'elfeed-update)
#+END_SRC
When reading articles in =elfeed-show-mode=, the content spans the entire buffer.
I like to read my content hard-wrapped at 80 chars, so I customize the built-in
=shr-width= ("Simple HTML Renderer," which is what Elfeed uses).
#+BEGIN_SRC emacs-lisp
(setq shr-width 80)
#+END_SRC
For YouTube videos, I like to play them right from Emacs with =mpv=.
#+BEGIN_SRC emacs-lisp
(defvar gm/youtube-dl-dir "videos/YouTube")

(defun gm/search-local-yt-video (id dir)
  (let ((default-directory dir))
    (with-temp-buffer
      (shell-command
       (format "find . -regextype sed -regex '.*\\[%s\\].mkv'" id)
       (current-buffer))
      (unless (string= (buffer-string) "")
        (expand-file-name (buffer-substring-no-properties
                           (+ 2 (line-beginning-position))
                           (line-end-position))
                          default-directory)))))

(defun gm/play-with-mpv (link &optional title)
  "Play file or link with mpv."
  (interactive)
  (let* ((id (nth 1 (s-split "watch\\?v=" link)))
         (video (gm/search-local-yt-video id (concat "~/" gm/youtube-dl-dir)))
         (drive-video-path (expand-file-name gm/youtube-dl-dir gm--drive-path)))
    (when (and (not video) (file-directory-p drive-video-path))
      (when-let ((drive-video (gm/search-local-yt-video id drive-video-path)))
        (setq video drive-video)))
    (unless title (setq title link))
    (if video
        (progn
          (message "Playing \"%s\" from local copy..." title)
          (setq link video))
      (message "Streaming \"%s\"..." title))
    (start-process
     "mpv" nil shell-file-name
     shell-command-switch
     (format "nohup 1>/dev/null 2>/dev/null %s \"%s\"" "umpv" link))))

(defun gm/elfeed-play-with-mpv ()
  "Play elfeed entry link with mpv."
  (interactive)
  (let* ((entry (gm/elfeed-get-entry))
         (link (elfeed-entry-link entry))
         (title (elfeed-entry-title entry)))
    (condition-case nil
        (elfeed-search-untag-all-unread)
      (error nil))
    (gm/play-with-mpv link title)
    (shell-command "i3-msg workspace 3")))
#+END_SRC
We make a multi-purpose function to open the link with =mpv= if it is a video,
otherwise with the browser.
#+BEGIN_SRC emacs-lisp
(defun gm/elfeed-get-entry ()
  (interactive)
  (if (eq major-mode 'elfeed-show-mode)
      elfeed-show-entry
    (elfeed-search-selected :single)))

(defun gm/elfeed-visit-or-play-with-mpv ()
  "Play in mpv if entry link matches `gm/elfeed-mpv-patterns', visit otherwise.
See `gm/elfeed-play-with-mpv'."
  (interactive)
  (let ((entry (gm/elfeed-get-entry)))
    (if (string-match gm/yt-regexp (elfeed-entry-link entry))
        (gm/elfeed-play-with-mpv)
      (if (eq major-mode 'elfeed-search-mode)
          (elfeed-search-browse-url)
        (elfeed-show-visit)))))
#+END_SRC
I don't want Firefox stealing the focus, because I like opening many links from
Emacs, then switching to Firefox to read them all. To fix this, I toggle
=browser.tabs.loadDivertedInBackground= to =true=, as per [[https://stackoverflow.com/questions/10506496/run-browse-url-in-emacs-without-giving-focus-to-the-browser][this SO post]].
We bind it to =o=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-settings
(bind-key "o" #'gm/elfeed-visit-or-play-with-mpv elfeed-show-mode-map)
(bind-key "o" #'gm/elfeed-visit-or-play-with-mpv elfeed-search-mode-map)
#+END_SRC
Sometimes I want to download videos to watch them later or in higher quality.
For this I use skeeto's =youtube-dl=.
#+BEGIN_SRC emacs-lisp
(autoload #'youtube-dl "youtube-dl")
(setq youtube-dl-directory (concat "~/" gm/youtube-dl-dir))
#+END_SRC
I wrap it for use in =elfeed=, but torrent if appropriate.
#+BEGIN_SRC emacs-lisp
(defun gm/dl-or-torrent ()
  (interactive)
  (let ((entry (elfeed-entry-link (gm/elfeed-get-entry))))
    (if (s-prefix-p "magnet:" entry)
        (progn
          (transmission-add entry)
          (elfeed-search-untag-all-unread))
      (youtube-dl entry))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-settings
(bind-key "d" #'gm/dl-or-torrent elfeed-show-mode-map)
(bind-key "d" #'gm/dl-or-torrent elfeed-search-mode-map)
#+END_SRC
Toggle the unread tag.
#+BEGIN_SRC emacs-lisp
(defun gm/elfeed-toggle-unread ()
  (interactive)
  (elfeed-search-toggle-all 'unread))
#+END_SRC
** Music
I got the setup information from [[https://www.reddit.com/r/emacs/comments/981khz/emacs_music_player_with_emms/][Reddit]] and [[https://www.youtube.com/watch?v=xTVN8UDScqk][this video]].
#+BEGIN_SRC emacs-lisp
(defvar gm/emms-started nil)

(defun gm/emms-setup ()
  (add-to-list 'load-path (expand-file-name "emms/lisp/" gmacs-custom-dir))
  (require 'emms-setup)
  (require 'emms-player-mpd)
  (emms-all)
  (require 'emms-mode-line)
  (emms-mode-line 1)
  (require 'emms-playing-time)
  (emms-playing-time 1)
  (unless gm/emms-started
    (setq gm/emms-started t)
    (condition-case nil
        (emms-player-mpd-connect)
      (error nil))))
#+END_SRC
We'll run our customizations once =emms= starts.
#+BEGIN_SRC emacs-lisp :noweb yes
(after! emms
    <<emms>>)
#+END_SRC
Now for the settings. I use =mpd= a minimal daemon for playing music.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref emms
(setq emms-seek-seconds 5
      emms-player-list '(emms-player-mpd)
      emms-info-list '(emms-info-mpd)
      emms-player-mpd-server-name "localhost"
      emms-player-mpd-server-port "6601"
      emms-source-file-default-directory "~/music/"
      emms-playlist-buffer-name "*Music*"
      emms-info-asynchronously t)
#+END_SRC
We use non-default settings for the socket. In order to use the built-in
functionality for =mpc=, we need to let Emacs know about this.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref emms
(setq mpc-host "localhost:6601")
#+END_SRC
When the music I have isn't tagged right or needs some editing, I use the
command line tool =id3v2= for quick or repetitive jobs. When appropriate, I prefer
the GUI application =easytag=.
*** Starting MPD from Emacs
#+BEGIN_SRC emacs-lisp
(defun mpd/start-music-daemon ()
  "Start MPD, connects to it and syncs the metadata cache."
  (interactive)
  (shell-command "mpd")
  (emms-player-mpd-update-all-reset-cache)
  (emms-player-mpd-connect)
  (emms-cache-set-from-mpd-all)
  (message "MPD Started!"))
#+END_SRC
*** Killing MPD from Emacs
#+BEGIN_SRC emacs-lisp
(defun mpd/kill-music-daemon ()
  "Stops playback and kill the music daemon."
  (interactive)
  (emms-stop)
  (call-process "killall" nil nil nil "mpd")
  (message "MPD Killed!"))
#+END_SRC
*** Bindings
I use a prefix map to compactify this set of keybindings.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-emms (:color pink :pre (gm/emms-setup))
  "
  ^
  ^EMMS^            ^Track^             ^MPD (daemon)^
  ^────────^──────────^──────^────────────^───────^─────
  _q_uit            _p_ause             _c_reate
  _e_mms            _P_revious          _k_ill
  _b_rowse          _N_ext              _r_eload
  ^^                _B_back (10s)       ^^
  ^^                _F_orward (10s)     ^^
  ^^                ^^                  ^^
  "
  ("q" nil)
  ("e" emms :color blue)
  ("b" emms-smart-browse :color blue)
  ("P" emms-previous)
  ("N" emms-next)
  ("p" emms-pause)
  ("B" emms-seek-backward)
  ("F" emms-seek-forward)
  ("k" mpd/kill-music-daemon)
  ("c" mpd/start-music-daemon)
  ("r" emms-player-mpd-update-all-reset-cache :color blue))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(bind-key "M-m" #'hydra-emms/body)
#+END_SRC
* Snippets
I use =SPC= instead of the default =TAB= to expand snippets. I find this more
convenient, because it makes typing a snippet more like typing a word. This
works fine apart from one hiccup. We need to bind =TAB= to =org-cycle= (even though
that is the default in Org Mode). Otherwise, binding =TAB= to =nil= in
=yas-minor-mode= overrides the default behaviour.
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :commands (yas-minor-mode yas-global-mode)
  :config
  (yas-global-mode 1)
  (bind-key "<tab>" nil yas-minor-mode-map)
  (bind-key "TAB" nil yas-minor-mode-map)
  (define-key yas-minor-mode-map (kbd "SPC")
    (or (bound-and-true-p yas-maybe-expand) #'yas-expand))
  :custom
  (yas-triggers-in-field t) ; expand snippets within snippets
  (yas-wrap-around-region t)
  (yas-snippet-dirs '("~/.emacs.d/snippets")))
(yas-global-mode 1)
(diminish 'yas-minor-mode " ✂")
#+END_SRC
** QuickMath
I use a hydra for snippets that just insert/replace text in math mode and thus
don't require the use of =yasnippets=.
*** Math Symbols
**** Main Math Snippets
Snippets go in [[file:math-snippets.el]].
#+BEGIN_SRC emacs-lisp
(defcustom gm/math-snippets nil
  "Contains lists (KEY EXPANSION SNIPPET). When KEY is typed, it
  will be replaced with EXPANSION. If SNIPPET is non-nil,
  EXPANSION is taken to be a loaded yasnippet. Otherwise, it is
  considered the replacement string."
  :type 'alist
  :group 'quick-math)

(defvar gm/math-global-snippets nil)
(defvar-local gm/math-local-snippets nil)
(defvar gm/math-snippet-loc (expand-file-name "math-snippets.el" user-emacs-directory))
#+END_SRC
**** Hydras
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-semicolon-a (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-b/body "Level 2")
  ("SPC" (insert "; ") ";")
  ("a" (insert "\\alpha{}") "α")
  ("A" (insert "\\forall ") "∀")
  ("b" (insert "\\beta{}") "β")
  ("C" (yas-expand-snippet (yas-lookup-snippet "mathcal")) "ℂ")
  ("c" (insert "\\xi{}") "ξ")
  ("C" (insert "\\Xi{}") "Ξ")
  ("d" (insert "\\delta{}") "δ")
  ("D" (insert "\\Delta{}") "Δ")
  ("e" (insert "\\epsilon{}") "ε")
  ("E" (insert "\\exists ") "∃")
  ("f" (insert "\\varphi{}") "φ")
  ("F" (insert "\\Phi{}") "Φ")
  ("g" (insert "\\gamma{}") "γ")
  ("G" (insert "\\Gamma{}") "Γ")
  ("h" (insert "\\eta{}") "η")
  ("i" (insert "\\iota{}") "ι")
  ("k" (insert "\\kappa{}") "κ")
  ("l" (insert "\\lambda{}") "λ")
  ("L" (insert "\\Lambda{}") "Λ")
  ("m" (insert "\\mu{}") "µ")
  ("n" (insert "\\nu{}") "ν")
  ("N" (insert "\\nabla") "∇")
  ("o" (insert "\\omega{}") "ω")
  ("O" (insert "\\Omega{}") "Ω")
  ("p" (insert "\\pi{}") "π")
  ("P" (insert "\\Pi{}") "Π")
  ("q" (insert "\\theta{}") "θ")
  ("Q" (insert "\\mathbb{Q}") "ℚ")
  ("r" (insert "\\rho{}") "ρ")
  ("R" (insert "\\mathbb{R}") "ℝ")
  ("s" (insert "\\sigma{}") "σ")
  ("t" (insert "\\tau{}") "τ")
  ("u" (insert "\\upsilon{}") "υ")
  ("U" (insert "\\cup ") "∪")
  ("v" (insert "\\vec ") "v")
  ("V" (insert "\\vee{}") "V")
  ("w" (insert "\\omega{}") "ω")
  ("W" (insert "\\Omega{}") "Ω")
  ("x" (insert "\\chi{}") "χ")
  ("y" (insert "\\psi{}") "ψ")
  ("Y" (insert "\\Psi{}") "Ψ")
  ("z" (insert "\\zeta{}") "ζ")
  ("Z" (insert "\\mathbb{Z}") "ℤ")
  ("0" (insert " \\emptyset") "∅")
  ("8" (insert "\\infinity") "∞")
  ("!" (insert "\\neg") "¬")
  ("*" (insert "\\star") "⋆")
  ("\\" (insert "\\setminus ") "∖")
  ("'" (insert "\\prime ") "′")
  ("," (insert ",\\ldots,") ".")
  ("." (insert "\\cdot ") "·"))

(defhydra hydra-semicolon-b (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-a/body "base")
  (" " (insert "; " "semicolon"))
  ("A" (insert "\\aleph ") "")
  ("e" (insert "\\varepsilon ") "ε")
  ("f" (insert "\\phi{}") "φ")
  ("F" (insert "\\mathbb{F}") "𝔽")
  ("l" (insert "\\ell{}") "ℓ")
  ("o" (insert "\\circ{}") "∘")
  ("q" (insert "\\Theta{}") "Θ")
  ("r" (insert "\\varrho ") "ρ")
  ("u" (insert "\\sqcup ") "∩")
  ("U" (insert "\\cap ") "∩")
  ("x" (insert " \\times ") "×")
  ("." (insert "\\cdots{}") "···"))
#+END_SRC
Then we bind this to semicolon.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref math-mode
(define-conditional-key gm/math-mode-map ";" #'hydra-semicolon-a/body (gm/in-math-p))
#+END_SRC
*** Helper Functions
**** QuickMath Minor Mode
#+BEGIN_SRC emacs-lisp :noweb no-export
(defvar gm/use-math-abbrevs nil)

(after! org
  (defvar gm/math-mode-map
    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map org-mode-map)
      map))
  <<math-mode>>

  (define-minor-mode quick-math-mode
    "Minor mode for math"
    :init-value nil
    :keymap gm/math-mode-map
    (when gm/user
          (abbrev-table-put org-mode-abbrev-table
                  :parents (list quick-math-mode-abbrev-table)))
    (when quick-math-mode
      (gm/math-setup)
      (gm/eq-preview-mode)
      (pretty-math-mode))))
#+END_SRC
We need shift-tabbing in snippets to override =org-shift-tab=, but only in math
mode.
#+BEGIN_SRC emacs-lisp
(define-conditional-key gm/math-mode-map (kbd "<S-iso-lefttab>") (lambda! (yas-next-field -1)) (gm/in-math-p))
#+END_SRC
**** Simpler =texmathp=
The default =texmathp= function assumes that you are writing valid LaTeX code.
This is all well and good when you are actually writing LaTeX, where things like
the dollar sign have only one meaning, but I write documents almost entirely in
Org Mode (I export them to LaTeX). Here the function easily gets confused. So I
make my own for checking if you are in math mode, which leverages Org Mode's
font-locking to narrow down the area we need to check. We first make a list of
math environments that our function will look for.
#+BEGIN_SRC emacs-lisp
(defvar gm/math-environments '("equation" "align")
  "The environments `gm/in-math-p' assumes as valid math environments.")
#+END_SRC
The only way we're in math mode is if we're in a LaTeX fragment. However, the
latter sometimes returns false positives when it comes to math mode. That is, we
can be in a LaTeX fragment (like a =figure= environment) without being in math
mode.

When Org says we're in inline LaTeX, we're definitely in math mode. If we're in
an environment, we check from the beginning of the environment to the point. If
there are more opening delimiters than closing ones (more of =\begin{ENV}= then
=\end{ENV}=, where =ENV= is an element of =gm/math-environments=), then the point must
be in math. The one subtlety is that we also look at the starred versions of
=ENV=.
#+BEGIN_SRC emacs-lisp
(defun gm/in-math-p (&optional loc)
  (if (boundp 'latex-mode)
      (when (eq major-mode 'latex-mode)
        (texmathp))
    (progn
      (unless loc (setq loc (point)))
      (defun gm/--in-math-p (begin-delim)
        (concat begin-delim (regexp-opt gm/math-environments) "[\\*]?}"))
      (let* ((fr (org-element-context))
             (fr-type (car fr))
             (begin (org-element-property :begin fr)))
        (save-excursion
          (if (condition-case nil
                  (progn
                    (re-search-backward "\\text{" begin)
                    (forward-word)
                    (forward-sexp)
                    (> (point) loc))
                (error nil))
              nil
            (cond ((eq fr-type 'latex-fragment)
                   (and
                    (>= loc begin)
                    (<= loc (1- (- (org-element-property :end fr)
                                   (org-element-property :post-blank fr))))))
                  ((eq fr-type 'latex-environment)
                   (let ((env-open (how-many (gm/--in-math-p "\\\\begin{") begin loc))
                         (env-close (how-many (gm/--in-math-p "\\\\end{") begin loc)))
                     (> (- env-open env-close) 0))))))))))
#+END_SRC
**** Enter Math Mode
Enter a math fragment if inside one, exit otherwise. We keep track of the number
of blank lines that follow the fragment, because according to Org, an =equation=
environment doesn't end until the first non-newline character that follows. This
makes for some awkward timing for activating previews.
#+BEGIN_SRC emacs-lisp
(defun gm/create-or-exit-math-fragment ()
  (interactive)
  (if (gm/in-math-p)
      (gm/reformat-fragment)
    (when (yas-active-snippets)
      (yas-exit-all-snippets))
    (if (org-in-src-block-p)
        (insert "$")
      (insert "\\(")
      (save-excursion (insert "\\)")))))
#+END_SRC
**** Last n Characters Before Point
Return the last n characters before the point, or =loc= if provided.
#+BEGIN_SRC emacs-lisp
(defun gm/last-n-chars (n &optional loc)
  (unless loc (setq loc (point)))
  (let ((start (- loc n)))
    (when (and (>= start (point-min))
               (<= start (point-max)))
      (buffer-substring-no-properties (- loc n) loc))))
#+END_SRC
**** Last LaTeX Letter
Postfix commands often act on the last letter. For example, I want =fhat= to
expand into =\hat{f}=. However, we cannot just act on the last letter, because
=\betahat= should expand into =\hat{beta}=, not the invalid =\bet\hat{a}=.
#+BEGIN_SRC emacs-lisp
(defun gm/last-letter ()
  (defun gm/--last-letter-helper ()
    (when (string-match "[a-zA-Z]" (gm/last-n-chars 1))
      (let ((match
             (if (looking-back (regexp-opt
                                (--map (concat "\\" (car it))
                                       (append gm/math-greek-lower
                                               gm/math-greek-upper)))
                               (- (point) 8) t)
                 (buffer-substring-no-properties (match-beginning 0)
                                                 (match-end 0))
               (char-to-string (char-before)))))
        (backward-char (length match))
        (cond ((string= (gm/last-n-chars 5) "\\vec ")
               (setq match (format "\\vec %s" match)))
              ((eq (char-before) ?\\)
               (setq match (format "\\%s" match))))
        match)))
  (save-excursion
    (if (string-match "}" (gm/last-n-chars 1))
        (progn (backward-char 2)
               (concat (gm/--last-letter-helper) "{}"))
      (gm/--last-letter-helper))))
#+END_SRC
I use this for postfix snippets, as explained.
#+BEGIN_SRC emacs-lisp
(defun gm/math-postfix (snippet)
  (let ((len (length (gm/last-letter))))
    (if (> len 0)
        (progn
          (backward-char len)
          (insert (format "\\%s{" snippet))
          (forward-char len)
          (insert "}"))
      (yas-expand-snippet (format "\\%s{$1}" snippet)))))
#+END_SRC
**** Test if LaTeX Needs to Be Wrapped in Brackets
#+BEGIN_SRC emacs-lisp
(defun gm/math-expression-p (math)
  (when math
    (or (eq (length math) 1)
        ;; match one single latex command, with opt-args and args
        ;; such as \command[1][2]{3}{4}
        ;; only validate if this is the entire string
        (string-match "\\`\\\\[[:alpha:]]+\\(\\[[^\\]]*]\\)*\\({[^}]*}\\)*\\'" math))))
#+END_SRC
**** Increment Snippet Fields
#+BEGIN_SRC emacs-lisp
(defun gm/increment-snippet-fields (string &optional n)
  (unless n (setq n 1))
  (replace-regexp-in-string "[1-9]+" (lambda (x) (format "%d" (+ n (string-to-number x)))) string))
#+END_SRC
**** Generate Snippets
:PROPERTIES:
:ORDERED:  t
:END:
I wrote this to reduce the amount of redundant code needed to set up the
snippets. First, we create a suffix tree of all the math snippets.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref math-mode
(defvar gm/longest-snippet)

(defun gm/math-setup ()
  (load gm/math-snippet-loc)
  (setq gm/math-snippets (append gm/math-local-snippets gm/math-global-snippets))
  (setq gm/longest-snippet
        (cons (-max (--map (length (car it)) gm/math-snippets))
              (-max (--map (length (cadr it)) gm/math-snippets))))
  (let ((unique-suffixes
         (delete-dups (--map (s-right 1 (car it)) gm/math-snippets))))
    (seq-do (lambda (key)
              (eval `(define-conditional-key gm/math-mode-map
                         ,key (lambda! () (gm/math-snippet-expand ,key))
                       (gm/in-math-p))))
            unique-suffixes)))
#+END_SRC
We make a function to get the possible completion candidates from the buffer.
#+BEGIN_SRC emacs-lisp
(defun gm/buff-cand (n)
  (cl-loop for i from 0 to n
        collect (gm/last-n-chars i)))
#+END_SRC
Then, we set up the creation of an actual snippet (note that its length is
capped at a certain number of characters, defined by =gm/longest-snippet=). The
longest snippet is currently =binom=, for the binomial coefficient (choose
function).
#+BEGIN_SRC emacs-lisp
(defun gm/math-snippet-expand (key)
  (insert key)
  (-if-let* ((buff-cand (gm/buff-cand (car gm/longest-snippet)))
             (completions (--keep (assoc it gm/math-snippets) buff-cand))
             (snippet (--max-by (> (length (car it)) (length (car other)))
                                completions)))
      (progn
        ;; this has to be negative, we're deleting back
        (delete-char (- 0 (length (car snippet))))
        ;; this is so we don't have two backslashes after something like \sim
        (when (= (char-before) ?\\) (delete-char -1))
        ;; is this a snippet expansion or just a text insertion?
        (let ((expand (cadr snippet)))
          (yas-expand-snippet (if (cddr snippet) (yas-lookup-snippet expand) expand))))
    (when (equal key "/")
      (gm/math-frac))))
#+END_SRC
**** Add and View Snippet
Now we give the user a way to easily add snippets.
#+BEGIN_SRC emacs-lisp
(defun gm/new-math-snippet ()
  "Creates a new math snippet. Adds the cons (KEY . NAME) to
`gm/math-snippets'. If no snippet with the name NAME exists in
the yasnippet directory for latex-mode, then the such a file is
created. The user can then write the code into which te snippet
should expand."
  (interactive)
  (let* ((key (read-string "Snippet key: "))
         (text (read-string "Snippet text (leave blank if using yasnippet): "))
         (name (when (s-blank-str? text)
                 (read-string "Snippet name: ")))
         (file-cand (expand-file-name
                     (format "%s/latex-mode/%s" (car (yas-snippet-dirs)) name)))
         (snippet (if (s-blank-str? text)
                      (list key name t)
                    (list key text)))
         (snippet-keys (--map (car it) gm/math-global-snippets))
         (snippet-list (--map (cons (car it) it) gm/math-global-snippets)))
    (unless (s-blank-str? name)
      (find-file file-cand)
      (unless (file-exists-p file-cand)
        (yas-expand-snippet (yas-lookup-snippet "new-math-snippet"))))
    (when (and (member (car snippet) snippet-keys)
               (y-or-n-p (format "Snippet %s is already defined. Overwrite?" key)))
      (setq gm/math-global-snippets (delete (cdr (assoc key snippet-list)) gm/math-global-snippets)))
    (push snippet gm/math-global-snippets)
    (unless current-prefix-arg
      (setq gm/math-global-snippets gm/math-global-snippets))
    (dump-vars-to-file '(gm/math-global-snippets) gm/math-snippet-loc t)
    (gm/math-setup)))
#+END_SRC
A very rudimentary command to see all current snippet keys and expansions.
#+BEGIN_SRC emacs-lisp
(defun gm/view-snippets ()
  (interactive)
  (setq gm/math-snippets
        (--sort (string< (car it) (car other)) gm/math-snippets))
  (with-output-to-temp-buffer "*QuickMath Expansions*"
    (let ((key-len (+ 4 (car gm/longest-snippet)))
          (snip-len (cdr gm/longest-snippet)))
      (princ (format "Key%s  Snippet%s\n%s%s\n"
                     (make-string (- key-len 4) ? )
                     (make-string (- snip-len 8) ? )
                     (make-string key-len ?-)
                     (make-string (1+ snip-len) ?-)))
      (dolist (snippet gm/math-snippets)
        (princ (format "%s %s\n"
                       (concat
                        (car snippet)
                        (make-string (- key-len (length (car snippet))) ? ))
                       (nth 1 snippet)))))))
#+END_SRC
**** Tab Jump to Next LaTeX Position
Modified from the =cdlatex-tab= function in =cdlatex.el=.
#+BEGIN_SRC emacs-lisp
(defun math-tab ()
  (interactive)
  (catch 'stop
    (cond
     ((looking-at "}\\|\\]\\|)")
      (forward-char 1)
      (if (or (looking-at "\\\\") (looking-at "[^_\\^({\\[]"))
          (throw 'stop t)))
     ((= (following-char) ?$)
      (while (= (following-char) ?$) (forward-char 1))
      (throw 'stop t))
     ((= (following-char) ?\ )
      (forward-char 1)
      (re-search-forward "[^ ]")
      (if (/= (preceding-char) ?\n) (forward-char -1)))
     (t
      (forward-char 1)))
    (while (re-search-forward "[ )}\n]\\|\\]" (point-max) t)
      (forward-char -1)
      (cond
       ((= (following-char) ?\ )
        (if (not (bolp)) (forward-char 1)) (throw 'stop t))
       ((= (following-char) ?\n)
        (if (and (bolp) (not (eobp)))
            (throw 'stop t)
          (if (equal "\\\\" (buffer-substring-no-properties
                             (- (point) 2) (point)))
              (forward-char 1)
            (throw 'stop t))))
       (t
        (if (or (= (char-syntax (preceding-char)) ?\()
                (= (char-syntax (preceding-char)) ?\))
                (= (preceding-char) ?-))
            (throw 'stop t)
          (forward-char 1)
          (if (looking-at "[^_\\^({\\[]")
              (throw 'stop t)))))))
  (unless (gm/in-math-p)
    (forward-char -1)
    (gm/reformat-fragment)))
#+END_SRC
Bind to tab.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref math-mode
(define-conditional-key gm/math-mode-map (kbd "<tab>") #'math-tab (gm/in-math-p))
#+END_SRC
**** Subscripts/Indices
This function eases the entry of subscripts such as $x_0$ or $a_{18}$. When a
digit is pressed, if the last character is a letter, then a subscript is
created. If this subscript is extended to a number with more than 1 digit,
brackets are added to ensure proper LaTeX rendering. I also rarely enter a
numbered subscript of more than two digits, so I also exit the brackets after
creating them.
#+BEGIN_SRC emacs-lisp
(defun gm/math-number-subscript (n)
  (insert n)
  (cond ((save-excursion
           (backward-char)
           (> (length (replace-regexp-in-string "[{}]" "" (if (gm/last-letter) (gm/last-letter) ""))) 1))
         (save-excursion
           (backward-char)
           (insert "_")))
        ((string-match "[a-zA-Z][0-9]" (gm/last-n-chars 2))
         (save-excursion
           (backward-char)
           (insert "_")))
        ((string-match "\_[0-9][0-9]" (gm/last-n-chars 3))
         (save-excursion
           (backward-char 2)
           (insert "\{"))
         (insert  "\}"))))
#+END_SRC
Add subscript bindings to each of the ten digits.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref math-mode
(cl-loop for i from 0 to 9
         collect (eval (macroexpand `(define-conditional-key gm/math-mode-map
                                         (number-to-string ,i)
                                         (lambda! () (gm/math-number-subscript (number-to-string ,i)))
                                       (gm/in-math-p)))))
#+END_SRC
**** Fraction
Typing =/= after an appropriate block (a number or a balanced set of parentheses)
creates a fraction with this block in the numerator and the point in the
denominator. The outside parentheses will be removed; for example, =(\sin x)/=
results in =\frac{\sin x}{|}=.
#+BEGIN_SRC emacs-lisp
(defvar gm/math-frac-extras
  '("\\\\vec"
    "\\\\Delta"))

(defun gm/math-insert-frac-match (match &optional env)
  (unless env (setq env "frac"))
  (when match
    (yas-expand-snippet (yas-lookup-snippet env))
    (insert match)
    (yas-next-field)))

(defun gm/math-frac-helper (regexp &optional env)
  (when (looking-back regexp (line-beginning-position) t)
    (let* ((begin (match-beginning 0))
           (end (match-end 0))
           (match (buffer-substring-no-properties begin end)))
      (delete-region begin end)
      (gm/math-insert-frac-match match env))))

(defun gm/math-frac (&optional env)
  (interactive)
  (when (eq (char-before) ?/) ;; remove /
    (delete-char -1))
  (cond
   ((use-region-p)
    (let* ((begin (region-beginning))
           (end (region-end))
           (match (buffer-substring-no-properties
                   begin end)))
      (delete-region begin end)
      ;; remove surrounding parens
      (when (string-match-p "\\`([^()]*)\\'" match)
        (setq match (substring match 1 -1)))
      (gm/math-insert-frac-match match env)))
   ((string-match "[\])]" (char-to-string (char-before)))
    (let ((end (point))
          (sqbracket (eq (char-before) 93)) ;; last char is sqbracket
          (env (if (eq (char-before) 41) "frac" "quotient"))
          match)
      (when sqbracket
        (backward-sexp))
      (backward-sexp)
      (setq match (buffer-substring-no-properties (point) end))
      (delete-region (point) end)
      (unless sqbracket
        (setq match (substring match 1 -1)))
      (gm/math-insert-frac-match match env)))
   ((eq (char-before) 125) ;; match closing curly braces
    (gm/math-frac-helper "[\\][a-z]*[\[{].*[\]}]" env))
   ((string-match "[[:alnum:]!]" (char-to-string (char-before)))
    (if (string-match "\\^" (char-to-string (char-before)))
        (yas-expand-snippet (yas-lookup-snippet (if env env "frac")))
      (gm/math-frac-helper
       (format "%s\\( \\|{}\\)%s"
               (regexp-opt gm/math-frac-extras t)
               "\\\\?[[:alnum:]_!]+")
       env)
      (if (and (yas-active-snippets)
               (eq (point)
                   (marker-position (yas--field-end (yas--snippet-active-field (car (yas-active-snippets)))))))  ;; check if snippet end here
          (gm/math-frac-helper "\\\\?[[:alnum:]_!]+" env)
        ;; Bit of a hacky fix
        (gm/math-frac-helper "\\\\?[[:alnum:]_^!]+" env))))
   (t (yas-expand-snippet (yas-lookup-snippet (if env env "frac"))))))
#+END_SRC
The binding is given in [[*Generate Snippets][Generate Snippets]].
**** Easy Split Environments
I wanted to make writing environments like =split= and =align= easier, so that I
wouldn't have to manually add the newline (=\\=) at the end of each line required
to make LaTeX happy.
#+BEGIN_SRC emacs-lisp
(defun gm/math-in-env-p (env)
  (when (gm/in-math-p)
    (save-excursion
      (if (eq major-mode 'org-mode)
          (org-backward-paragraph)
        (backward-paragraph))
      (forward-line)
      (equal (buffer-substring-no-properties
              (line-beginning-position)
              (line-end-position))
             (format "\\begin{%s}" env)))))

(defun gm/tex-newline ()
  (interactive)
  (let ((current-line (buffer-substring-no-properties
                       (line-beginning-position)
                       (line-end-position))))
    (if (equal current-line "\\begin{split}")
        (newline)
      (end-of-line)
      (unless (equal (gm/last-n-chars 2) "\\\\")
        (insert " \\\\"))
      (if (save-excursion
            (forward-line)
            (equal (buffer-substring-no-properties
                    (line-beginning-position)
                    (line-end-position))
                   "\\end{split}"))
          (progn
            (newline)
            (when (equal (substring (s-trim current-line) 0 2) "&=")
              (insert "&= ")))
        (forward-line)))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref math-mode
(define-conditional-key gm/math-mode-map (kbd "RET") #'gm/tex-newline (gm/math-in-env-p "split"))
#+END_SRC
**** Convert Inline Math to Equation
Turns an inline math snippet into an equation.
#+BEGIN_SRC emacs-lisp
(defun gm/math-inline-to-equation ()
  (interactive)
  (let* ((fr (org-element-context))
         (fr-begin (org-element-property :begin fr))
         (fr-end (org-element-property :end fr))
         (match (buffer-substring-no-properties
                 (+ fr-begin 2)
                 (- fr-end 2)))
         (char (char-to-string (char-after fr-end))))
    (delete-region fr-begin (if (string-match "\\.\\|," char)
                                (1+ fr-end)
                              fr-end))
    (newline)
    (insert "\\begin{equation}\n")
    (insert match)
    (when (string-match "\\.\\|," char) (insert char))
    (save-excursion
      (insert "\n\\end{equation}\n")
      (when (eq (char-after) ? )
        (hungry-delete-forward 0)))))
#+END_SRC
**** Add Float to Marginnote
I often add a margin note then decide to shift it down. However, margin notes
and shifted notes use different link types.
#+BEGIN_SRC emacs-lisp
(defun gm/math-make-marginnote-float ()
  (interactive)
  (if (org-in-regexp org-bracket-link-regexp 1)
      (let* ((remove (list (match-beginning 0) (match-end 0)))
             (description (match-string-no-properties 3))
             (shift-regexp ";[0-9]*ex")
             (shift (if (string-match-p shift-regexp description)
                        (s-replace "ex" "" (nth 1 (split-string description ";")))
                      "0"))
             (element (org-element-context))
             (path (org-element-property :path element)))
        (when (equal path "marginnote")
          (apply 'delete-region remove)
          (insert (format "[[latex-opt:marginnote][%s;0ex]]" (replace-regexp-in-string shift-regexp "" description)))))))
#+END_SRC
*** Inkscape Figures
This is the mode we will load in Inkscape when we insert math.
#+BEGIN_SRC emacs-lisp
(define-derived-mode inkmath-mode org-mode "Ink" ()
  :after-hook (flyspell-mode -1)
  (quick-math-mode)
  (pretty-math-mode)
  (setq mode-line-format nil)
  (when (= (point) (point-min))
    (funcall-interactively 'forward-char 2)))

(defun gm/inkmath-end ()
  (interactive)
  (save-buffer)
  (delete-frame))

(bind-key [remap org-ctrl-c-ctrl-c] #'gm/inkmath-end inkmath-mode-map)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.inkmath\\'" . inkmath-mode))
#+END_SRC
I don't want to mark these files as recently visited.
#+BEGIN_SRC emacs-lisp
(after! recentf
  (push ".*inkmath$" recentf-exclude))
#+END_SRC
We need a way to make Inkscape figures from Emacs. The =org-inkscape-figure=
snippet calls this function.
#+BEGIN_SRC emacs-lisp
(defun gm/inkscape-figure ()
  (interactive)
  (let ((imgdir (expand-file-name "figures/" default-directory)))
    (unless (file-directory-p imgdir)
      (mkdir imgdir))
    (let ((default-directory imgdir)
          (name (read-string "Figure name: ")))
      (call-process "inkscape-figures" nil 0 nil
                    "create" name)
      (shell-command "i3-msg \"fullscreen\"")
      (shell-command "i3-msg \"fullscreen\"")
      (setf (buffer-substring
             (line-beginning-position) (line-end-position)) "")
      (yas-expand-snippet (format "#+name: fig:%s\n #+caption: $2\n #+attr_latex: :vertical-alignment b\n [[file:figures/%s.pdf_tex]]\n$0" name name)))))
      #+END_SRC
